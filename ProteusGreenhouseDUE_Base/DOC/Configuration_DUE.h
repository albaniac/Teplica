#pragma once
//--------------------------------------------------------------------------------------------------------------------------------
#if (TARGET_BOARD != DUE_BOARD)
	#error "Target board MUST BE DUE_BOARD for this configuration!"
#endif
//--------------------------------------------------------------------------------------------------------------------------------
#define I2C_SPEED 100000UL // скорость работы I2C (400000UL, 100000UL)
//#define MEASURE_TEMPERATURES_IN_FAHRENHEIT // раскомментируйте эту настройку, если вам надо измерять температуру не в градусах Цельсия, а в Фаренгейтах
#define USE_DS3231_REALTIME_CLOCK // ИСПОЛЬЗОВАНИЕ ЧАСОВ РЕАЛЬНОГО ВРЕМЕНИ - ОБЯЗАТЕЛЬНО !!!
#define DS3231_WIRE_NUMBER 0 // номер I2C для часов (0 - первый I2C, 1 - второй I2C)
//#define USE_INTERNAL_CLOCK
#define INTERNAL_CLOCK_OSC XTAL
//--------------------------------------------------------------------------------------------------------------------------------
// настройки модулей
//--------------------------------------------------------------------------------------------------------------------------------
#define USE_SCENE_MODULE // закомментировать, если не нужен модуль сценариев. Сценарии создаются при помощи программы SceneCreator.exe, и загружаются на SD-карту.
#define USE_PIN_MODULE // закомментировать, если не нужен модуль управления пинами
#define USE_MCP_MODULE // раскомментировать, если надо управлять микросхемами MCP* с внешних команд (CTGET и CTSET, а также через MQTT командами GET и SET)
#define USE_TEMP_SENSORS // закомментировать, если не нужно управление фрамугами и температурные датчики
#define USE_WINDOWS_SHIFT_REGISTER // использовать ли сдвиговый регистр 74HC595 для управления окнами, вместо контроля пинов напрямую
#define USE_STAT_MODULE // закомментировать, если не нужна поддержка модуля статистики (FREERAM, UPTIME, DATETIME)
#define USE_SMS_MODULE // закомментировать, если не нужна поддержка управления по SMS (SIM800)
#define USE_WATERING_MODULE // закомментировать, если не нужен модуль управления поливом
#define USE_LUMINOSITY_MODULE // закомментировать, если не нужен модуль контроля освещенности (BH17500 и MAX44009)
#define USE_HUMIDITY_MODULE // закомментировать, если не нужен модуль работы с датчиками влажности DHT, Si7021, SHT
#define USE_SOIL_MOISTURE_MODULE // закомментировать, если не нужен модуль датчиков влажности почвы
//#define USE_PH_MODULE // закомментировать, если не нужен модуль снятия показаний с датчиков pH и контроля за дозированием реагентов в систему
#define USE_LOG_MODULE // закомментировать, если не нужен модуль логгирования информации
#define USE_DELTA_MODULE // закомментировать, если не нужно собирать показания дельт с датчиков (разница показаний между двумя датчиками)
#define USE_WATERFLOW_MODULE // закомментировать, если не нужны датчик(и) расхода воды
#define USE_COMPOSITE_COMMANDS_MODULE // закомментировать, если не нужен модуль составных команд (позволяет выполнить скопом несколько разных действий, используется правилами)
#define USE_RESERVATION_MODULE // закомментировать, если не нужем модуль резервирования датчиков (когда при отсутствии показаний с одного датчика показания берутся со связанных с ним).
#define USE_TIMER_MODULE // закомментировать, если не нужна поддержка модуля таймеров (4 таймера)
#define USE_IOT_MODULE // закомментировать, если не нужна отсылка данных на IoT-хранилища (ThingSpeak)
#define USE_ALARM_DISPATCHER // закомментировать, если не нужны тревоги (получение СМС при срабатывании правила)
#define USE_WIFI_REBOOT_PIN // закомментировать, если не надо управлять пином выключения питания при зависании ESP
#define USE_GSM_REBOOT_PIN // закомментировать, если не надо управлять пином выключения питания при зависании SIM800
#define USE_NRF_REBOOT_PIN // закомментировать, если не надо управлять пином выключения питания при зависании nRF
#define USE_LORA_REBOOT_PIN // закомментировать, если не надо управлять пином выключения питания при зависании LoRa
//#define USE_W5100_REBOOT_PIN // закомментировать, если не надо управлять пином выключения питания при зависании W5100
#define USE_EXTERNAL_WATCHDOG // закомментировать, если не нужен внешний контроль зависания контроллера
#define USE_WIFI_MODULE_AS_IOT_GATE // закомментировать, если не хотим использовать ESP как один из шлюзов для отсыла данных в IoT
#define USE_WIFI_MODULE_AS_HTTP_PROVIDER // закомментировать, если не хотим посылать HTTP-запросы к сервису gardenboss.ru через ESP
#define USE_WIFI_MODULE_AS_MQTT_CLIENT // раскомментировать, если хотим использовать ESP как MQTT-клиент
#define MQTT_REPORT_AS_JSON // раскомментировать, если надо публиковать топик-ответ на выполнение команды в объекте JSON
//#define USE_GSM_MODULE_AS_IOT_GATE // закомментировать, если не хотим использовать GSM-модем как один из шлюзов для отсыла данных в IoT
//#define USE_GSM_MODULE_AS_HTTP_PROVIDER // закомментировать, если не хотим посылать HTTP-запросы к сервису gardenboss.ru через GSM
//#define USE_UNIVERSAL_MODULES // закомментировать, если не нужно использовать никакие универсальные модули
//#define USE_REMOTE_DISPLAY_MODULE // раскомментировать, если нужна поддержка модуля с выносным дисплеем на шине RS-485
//#define USE_RS485_EXTERNAL_CONTROL_MODULE // закомментировать, если не надо использовать выносной модуль на 7 кнопок с привязками к командам
//#define USE_UNI_EXECUTION_MODULE // закомментировать, если не нужна поддержка универсальных исполнительных модулей
#define USE_UNI_REGISTRATION_LINE // закомментировать, если не нужна проводная линия 1-Wire для регистрации универсальных модулей
//#define USE_RS485_GATE // закомментировать, если не нужна поддержка опроса универсальных модулей по протоколу RS-485
//#define USE_NRF_GATE // закомментировать, если не нужно работать с универсальными модулями по радиоканалу nRF
//#define USE_LORA_GATE // закомментировать, если не нужно работать с универсальными модулями по радиоканалу LoRa (чипы SX1276/77/78/79)
#define USE_PUMP_RELAY // закомментировать, если не нужен отдельный канал управления насосом при поливе
#define USE_SECOND_PUMP // использовать ли второй насос для полива. Директива USE_PUMP_RELAY при использовании второго насоса также должна быть определена!
#define USE_HTTP_MODULE // закомментировать, если не нужна проверка на входящие команды и отсыл данных на сервис gardenboss.ru
//--------------------------------------------------------------------------------------------------------------------------------
// расширители портов
//--------------------------------------------------------------------------------------------------------------------------------
//#define USE_MCP23S17_EXTENDER // использовать или нет расширители портов MCP23S17
#define USE_MCP23017_EXTENDER // использовать или нет расширители портов MCP23017
//--------------------------------------------------------------------------------------------------------------------------------
// шлюзы (ИСПОЛЬЗОВАТЬ ВМЕСТЕ НЕ ДОПУСКАЕТСЯ, прошивка не скомпилируется!)
//--------------------------------------------------------------------------------------------------------------------------------
#define USE_WIFI_MODULE // закомментировать, если не нужна поддержка управления через Wi-Fi
//#define USE_W5100_MODULE // закомментировать, если не нужна работа по Ethernet через W510
//--------------------------------------------------------------------------------------------------------------------------------
// экраны (ИСПОЛЬЗОВАТЬ ВМЕСТЕ НЕ ДОПУСКАЕТСЯ, прошивка не скомпилируется!)
//--------------------------------------------------------------------------------------------------------------------------------
//#define USE_LCD_MODULE // закомментировать, если не нужен дисплей 128х64 на базе контроллера ST7920
//#define USE_NEXTION_MODULE // закомментировать, если не нужна поддержка Nextion
#define USE_TFT_MODULE // закомментировать, если не нужна поддержка 7'' TFT на контроллере SSD1963 с разрешением 800x480
//--------------------------------------------------------------------------------------------------------------------------------
// информационные диоды
//--------------------------------------------------------------------------------------------------------------------------------
#define USE_READY_DIODE // закомментировать, если не нужен диод, горящий при работе контроллера
#define BLINK_READY_DIODE // закомментировать, если не нужно периодически мигать диодом работы
#define USE_WINDOWS_MANUAL_MODE_DIODE // закомментировать, если не нужен диод, мигающий в ручном режиме управления фрамугами
#define USE_WATERING_MANUAL_MODE_DIODE // закомментировать, если не нужен диод, мигающий в ручном режиме управления поливом
#define USE_LIGHT_MANUAL_MODE_DIODE // закомментировать, если не нужен диод, мигающий в ручном режиме управления досветкой
//--------------------------------------------------------------------------------------------------------------------------------
// обратная связь
//--------------------------------------------------------------------------------------------------------------------------------
#define USE_FEEDBACK_MANAGER // закомментировать, если не нужно использовать модуль обратной связи по положению окон
#define FEEDBACK_MANAGER_WAIT_TIME 15000 // если в течение указанного кол-ва миллисекунд после старта контроллера не придёт информация по положению окон - окна принудительно погонятся контроллером в закрытую позицию, чтобы обеспечить начальную точку отсчёта
#define FEEDBACK_MANAGER_UPDATE_INTERVAL 5000 // через сколько миллисекунд запрашивать информацию у модулей обратной связи
#define FEEDBACK_MANAGER_POSITION_HISTERESIS 500 // кол-во миллисекунд работы моторов, которое следует игнорировать, если текущая позиция окон находится в рамках этого гистерезиса, т.е. разница текущей позиции и запрошенной - меньше гистерезиса
//--------------------------------------------------------------------------------------------------------------------------------
// настройки MCP23S17
//--------------------------------------------------------------------------------------------------------------------------------
#define MCP23S17_CS_PIN 46 // номер пина chip select для микросхем MCP23S17
#define COUNT_OF_MCP23S17_EXTENDERS 0 // сколько расширителей портов MCP23S17 используется (0 - нисколько)
#define MCP23S17_ADDRESSES 0 // адреса расширителей MCP23S17, через запятую, кол-вом COUNT_OF_MCP23S17_EXTENDERS
//--------------------------------------------------------------------------------------------------------------------------------
// настройки MCP23017
//--------------------------------------------------------------------------------------------------------------------------------
#define COUNT_OF_MCP23017_EXTENDERS 3 // сколько расширителей портов MCP23017 используется (0 - нисколько)
#define MCP23017_ADDRESSES 1, 2, 4 // адреса расширителей MCP23017, через запятую, кол-вом COUNT_OF_MCP23017_EXTENDERS (0 - первый адрес 0x20, 1 - второй адрес 0x21 и т.п.)
//--------------------------------------------------------------------------------------------------------------------------------
// настройки Watchdog
//--------------------------------------------------------------------------------------------------------------------------------
#define WATCHDOG_REBOOT_PIN 66 // номер пина, на котором будут меняться уровни
#define WATCHDOG_NORMAL_LEVEL  LOW // уровень на ноге, который держится WATCHDOG_WORK_INTERVAL миллисекунд
#define WATCHDOG_TRIGGERED_LEVEL  HIGH // уровень импульса на ноге, который держится WATCHDOG_PULSE_DURATION миллисекунд
#define WATCHDOG_WORK_INTERVAL 5000 // через сколько миллисекунд на ноге будет уровень WATCHDOG_TRIGGERED_LEVEL
#define WATCHDOG_PULSE_DURATION 200 // сколько миллисекунд держать уровень WATCHDOG_TRIGGERED_LEVEL на ноге
//--------------------------------------------------------------------------------------------------------------------------------
// настройки выносных модулей
//--------------------------------------------------------------------------------------------------------------------------------
#define UNI_REGISTRATION_PIN 69 // номер пина, на котором будут регистрироваться модули в системе
#define UNI_MODULE_UPDATE_INTERVAL 2000 // через сколько мс обновлять показания с универсального модуля
#define UNI_WIRED_MODULES_COUNT 0 // сколько проводных линий для универсальных модулей используется (0 - нисколько)
#define UNI_WIRED_MODULES 0 // номера пинов (через запятую), на которых висят универсальные модули, кол-вом  UNI_WIRED_MODULES_COUNT
//--------------------------------------------------------------------------------------------------------------------------------
// настройки RS-485
//--------------------------------------------------------------------------------------------------------------------------------
#define RS_485_SERIAL Serial3 // Какой UART использовать для RS-485
#define RS_485_DE_PIN 68 // номер пина, на котором будет происходить переключение приёма/передачи по RS-485
#define RS485_STATE_PUSH_FREQUENCY 1000 // через сколько миллисекунд писать в шину RS-485 слепок состояния контроллера
#define RS485_ONE_SENSOR_UPDATE_INTERVAL 1234 // через сколько миллисекунд запрашивать с шины RS-485 показания одного датчика (полный цикл опроса будет равен интервалу*кол-во датчиков в системе)
#define RS485_BYTES_TIMEOUT 10 // кол-во байт, после неуспешной попытки вычитки которых принимать решение о таймауте (если данные по RS-485 не ходят - увеличьте это значение).
#define RS485_RESET_SENSOR_AFTER_N_BAD_READINGS 5 // через сколько неудачных чтений с датчика сбрасывать его значения на вид "<нет данных>"
//--------------------------------------------------------------------------------------------------------------------------------
// настройки nRF
//--------------------------------------------------------------------------------------------------------------------------------
#define UNI_DEFAULT_RF_CHANNEL 19 // номер канала для nRF по умолчанию
#define NRF_CE_PIN 42 // номер пина CE для модуля nRF
#define NRF_CSN_PIN 43 // номер пина CSN для модуля nRF
#define NRF_CONTROLLER_STATE_CHECK_FREQUENCY 789 // через сколько миллисекунд проверять смену состояния контроллера (для отсылки в эфир при изменениях)
#define NRF_REBOOT_PIN 12 // номер пина для пересброса питания nRF
#define NRF_POWER_ON  LOW // уровень включения питания
#define NRF_POWER_OFF  HIGH // уровень выключения питания
//#define NRF_AUTOACK_INVERTED // раскомментировать эту строчку здесь и в прошивках универсальных модулей, если у вас они не коннектятся. Иногда auto aсk в китайских модулях имеет инвертированное значение.
//--------------------------------------------------------------------------------------------------------------------------------
// настройки LoRa
//--------------------------------------------------------------------------------------------------------------------------------
#define LORA_SS_PIN 56 // пин SS для LoRa
#define LORA_RESET_PIN 48 // пин Reset для LoRa
#define LORA_FREQUENCY 433E6 // частота работы (433E6, 866E6, 915E6)
#define LORA_TX_POWER 17 // мощность передатчика (1 - 17)
#define LORA_CONTROLLER_STATE_CHECK_FREQUENCY 1348 // через сколько миллисекунд проверять смену состояния контроллера (для отсылки в эфир при изменениях)
#define LORA_REBOOT_PIN 60 // номер пина для пересброса питания LoRa
#define LORA_POWER_ON  LOW // уровень включения питания
#define LORA_POWER_OFF  HIGH // уровень выключения питания
//--------------------------------------------------------------------------------------------------------------------------------
// настройки таймеров
//--------------------------------------------------------------------------------------------------------------------------------
#define TIMER_ON  HIGH // уровень, который надо выставлять на пине, когда таймер включён
#define TIMER_OFF  LOW // уровень, который надо выставлять на пине, когда таймер выключён
#define TIMERS_DRIVE_MODE  DRIVE_DIRECT // режимы управления пинами модуля таймеров - [DRIVE_DIRECT, DRIVE_MCP23S17, DRIVE_MCP23017]
#define TIMERS_MCP23S17_ADDRESS 0 // адрес микросхемы MCP23S17, через которую рулим пинами таймеров (если управление в режиме DRIVE_MCP23S17)
#define TIMERS_MCP23017_ADDRESS 0 // адрес микросхемы MCP23017, через которую рулим пинами таймеров (если управление в режиме DRIVE_MCP23017)
//--------------------------------------------------------------------------------------------------------------------------------
// настройки EEPROM
//--------------------------------------------------------------------------------------------------------------------------------
#define EEPROM_USED_MEMORY EEPROM_AT24C32 // какую память мы используем
#define EEPROM_MEMORY_INDEX 0 // адрес микросхемы памяти на шине I2C
#define SETT_HEADER1 0x1F // байты, сигнализирующие о наличии сохранённых настроек, первый
#define SETT_HEADER2 0xBF // и второй
#define CONTROLLER_ID_EEPROM_ADDR 1 // по какому адресу располагается ID контроллера, 1 байт
#define UNI_SENSOR_INDICIES_EEPROM_ADDR 2 // с какого адреса идут выданные индексы для универсальных сенсоров, 10 байт
#define WIFI_STATE_EEPROM_ADDR 12 // адрес хранения состояния Wi-Fi (коннектится к роутеру или нет), 1 байт
#define STATION_PASSWORD_EEPROM_ADDR 13 // адрес хранения пароля к точке ESP, 20 байт
#define STATION_ID_EEPROM_ADDR 33 // адрес хранения ID точки доступа ESP, 20 байт
#define ROUTER_PASSWORD_EEPROM_ADDR 53 // адрес хранения пароля к роутеру, 20 байт
#define ROUTER_ID_EEPROM_ADDR 73 // адрес хранение ID роутера, 20 байт
#define SMS_NUMBER_EEPROM_ADDR 93 // адрес хранения номера телефона хозяина, 15 байт
#define GSM_PROVIDER_EEPROM_ADDR 108 // адрес хранения оператора GSM, 1 байт
#define IOT_SETTINGS_EEPROM_ADDR 109 // адрес хранения настроек IOT, 51 байт
#define OPEN_INTERVAL_EEPROM_ADDR 160 // адрес хранения настроек интервала открытия окон, 4 байта
#define CLOSE_TEMP_EEPROM_ADDR 164 // адрес хранения температуры закрытия, 1 байт
#define OPEN_TEMP_EEPROM_ADDR 165 // адрес хранения температуры открытия, 1 байт
#define WATERING_OPTION_EEPROM_ADDR 166 // адрес хранения текущей опции полива, 1 байт
#define TURN_PUMP_EEPROM_ADDR 167 // адрес хранения флага - включить ли насос при поливе, 1 байт
#define START_WATERING_TIME_EEPROM_ADDR 168 // адрес хранения начала полива для всех каналов, 2 байта
#define WATERING_TIME_EEPROM_ADDR 170 // адрес хранения продолжительности полива для всех каналов, 2 байта
#define WATERING_WEEKDAYS_EEPROM_ADDR 172 // адрес хранения маски дней недели полива на всех каналах, 1 байт
#define WATERING_SENSOR_EEPROM_ADDR 173 // адрес хранения индекса датчика в модуле влажности почв, показания с которого учитываются при поливе, 1 байт
#define WATERING_STOP_BORDER_EEPROM_ADDR 174 // адрес хранения показаний с датчика, по которым полив на всех каналах выключается, 1 байт
#define WATERING_CHANNELS_SETTINGS_EEPROM_ADDR 175 // адрес начала настроек каналов полива, 16 каналов*7 байт на канал - 112 байт
#define WATERING_TURN_TO_AUTOMODE_AFTER_MIDNIGHT_ADDRESS 299 // адрес настройки "переходить в авторежим после полуночи", 1 байт
#define WATERING_STATUS_EEPROM_ADDR 300 // с какого адреса у нас идут статусы каналов полива, по 5 байт на канал, 100 байт
#define WATERFLOW_EEPROM_ADDR 400 // с какого адреса у нас будут записываться показания датчиков расхода воды, 12 байт
#define DELTA_SETTINGS_EEPROM_ADDR 412 // с какого адреса в EEPROM начинаются настройки дельт, 500 байт на 20 дельт
#define PH_SETTINGS_EEPROM_ADDR 912 // с какого адреса идут настройки PH-модуля, 30 байт
#define TIMERS_EEPROM_ADDR 942 // у нас 4 таймера, на каждый - 10 байт + заголовок (2 байта), итого - 42 байта 
#define RESERVATION_ADDR 984 // адрес, с которого пишутся настройки резервирования (10 списков по 12 байт + 3 байта = 123 байта)
#define GUID_ADDRESS 1110 // адрес, по которому хранится уникальный GUID контроллера (32 символа без пробелов + 2 байта - заголовок присутствия - 34 байта)
#define HTTP_API_KEY_ADDRESS 1144 // адрес, ко которому хранится ключ доступа к HTTP API (32 символа без пробелов + 2 байта - заголовок присутствия + 1 байт - флаг активности, вкл/выкл) - 35 байт
#define HTTP_SEND_SENSORS_DATA_ADDRESS 1179 // адрес хранения флага - отсылать ли слепок показаний датчиков контроллера при проверке задач по HTTP, 1 байт
#define TIMEZONE_ADDRESS 1180 // адрес хранения часового пояса контроллера, 4 байта (2 байта заголовок присутствия, 2 байта - таймзона). Хранится в минутах
#define HTTP_SEND_STATUS_ADDRESS 1184 // адрес хранения флага - отсылать ли слепок состояния контроллера при проверке задач по HTTP, 1 байт
#define MQTT_ENABLED_FLAG_ADDRESS 1185 // адрес хранения флага - активен ли MQTT-клиент, 1 байт
#define MQTT_INTERVAL_BETWEEN_TOPICS_ADDRESS 1186 // адрес хранения интервала (в секундах) между публикацией топиков в брокер MQTT, 1 байт
#define COMPOSITE_COMMANDS_START_ADDR 3248 // с какого адреса в EEPROM идут составные команды
#define EEPROM_RULES_START_ADDR 5120 // с какого адреса в EEPROM идут правила
//--------------------------------------------------------------------------------------------------------------------------------
// настройки Serial
//--------------------------------------------------------------------------------------------------------------------------------
#define SERIAL_BAUD_RATE 57600 // скорость работы с портами, бод
//--------------------------------------------------------------------------------------------------------------------------------
// настройки информационных диодов
//--------------------------------------------------------------------------------------------------------------------------------
#define INFO_DIODES_DRIVE_MODE  DRIVE_MCP23017 // как рулим информационными диодами [DRIVE_DIRECT, DRIVE_MCP23S17, DRIVE_MCP23017]
#define INFO_DIODES_MCP23S17_ADDRESS 4 // адрес микросхемы MCP23S17, через которую рулим информационными диодами (если управление в режиме DRIVE_MCP23S17)
#define INFO_DIODES_MCP23017_ADDRESS 4 // адрес микросхемы MCP23017, через которую рулим информационными диодами (если управление в режиме DRIVE_MCP23017)
#define DIODE_READY_PIN 9 // пин или номер канала расширителя портов, на котором висит диод индикации работы
#define DIODE_WINDOWS_MANUAL_MODE_PIN 10 // пин или номер канала расширителя портов, на котором будет диод, мигающий, когда мы в ручном режиме управления окнами
#define DIODE_WATERING_MANUAL_MODE_PIN 11 // пин или номер канала расширителя портов, на котором висит диод индикации ручного режима управления поливом
#define DIODE_LIGHT_MANUAL_MODE_PIN 12 // пин или номер канала расширителя портов, на котором висит диод индикации ручного режима управления досветкой
#define WORK_MODE_BLINK_INTERVAL 500 // с какой частотой мигать на пинах индикации ручного режима работы, мс
#define READY_DIODE_BLINK_INTERVAL 5000 // с какой частотой мигать диодом работы, мс
//--------------------------------------------------------------------------------------------------------------------------------
// настройки SD и нумерации виртуальных пинов
//--------------------------------------------------------------------------------------------------------------------------------
#define SDCARD_CS_PIN 52 // номер пина Chip Select для SD-модуля
#define VIRTUAL_PIN_START_NUMBER 80 // номер пина, с которого все пины будут считаться виртуальными, т.е. запись в них производиться не будет, однако в карте пинов (16 байт) этот статус будет отражён.
//--------------------------------------------------------------------------------------------------------------------------------
// настройки железных модулей реле
//--------------------------------------------------------------------------------------------------------------------------------
#define RELAY_ON  LOW // уровень для включения реле фрамуг
#define RELAY_OFF  HIGH // уровень для выключения реле фрамуг
#define SHORT_CIRQUIT_STATE  HIGH // статус пинов, на которых висит реле фрамуг, чтобы закоротить мотор и не дать ему крутиться
//--------------------------------------------------------------------------------------------------------------------------------
// настройки максимумов
//--------------------------------------------------------------------------------------------------------------------------------
#define MAX_ALERT_RULES 50 // максимальное кол-во поддерживаемых правил
#define MAX_DELTAS 20 // максимальное кол-во дельт. Внимание: на 20 дельт нужно примерно 500 байт в EEPROM, следите за непересечением адресов!!!
//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля правил
//--------------------------------------------------------------------------------------------------------------------------------
//#define ALERT_INCLUDE_COMMA_VALUES // раскомментировать, если в правилах надо сравнивать не только целую часть показаний, но и дробную
#define ALERT_DONT_READ_PIN_DIRECT // закомментировать, если хотите, чтобы в режиме слежения за состоянием пина модуль правил читал прямо из него. При этом пин настраивается на вход. Если настройка активна - в режиме слежения за пином модуль правил читает из карты состояний пинов, не трогая пин контроллера.
//--------------------------------------------------------------------------------------------------------------------------------
// настройки интервалов обновлений модулей
//--------------------------------------------------------------------------------------------------------------------------------
#define ALERT_UPDATE_INTERVAL 500 // интервал обновления состояния модуля ALERT, мс. Нужен, чтобы часто не разрешать зависимости - это ресурсоёмкая операция.
#define LOGGING_INTERVAL 300000 // интервал логгирования, мс (300000 - каждые 5 минут и т.п.)
#define LUMINOSITY_UPDATE_INTERVAL 3000 // через сколько мс обновлять показания с датчиков освещенности
#define HUMIDITY_UPDATE_INTERVAL 5000 // через сколько мс обновлять показания с датчиков влажности
#define TEMP_UPDATE_INTERVAL 4990 // через сколько мс обновлять показания с датчиков температуры
#define DELTA_UPDATE_INTERVAL 5010 // через сколько миллисекунд обновлять показания дельт?
//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля освещенности
//--------------------------------------------------------------------------------------------------------------------------------
#define LIGHT_DRIVE_MODE  DRIVE_MCP23017 // режимы управления пинами - [DRIVE_DIRECT, DRIVE_MCP23S17, DRIVE_MCP23017]
#define LIGHT_MCP23S17_ADDRESS 1 // адрес микросхемы MCP23S17, через которую рулим каналами досветки (если управление в режиме DRIVE_MCP23S17)
#define LIGHT_MCP23017_ADDRESS 1 // адрес микросхемы MCP23017, через которую рулим каналами досветки (если управление в режиме DRIVE_MCP23017)
#define LIGHT_RELAY_ON  LOW // уровень для включения реле
#define LIGHT_RELAY_OFF  HIGH // уровень для выключения реле
#define LIGHT_SENSORS_COUNT 1 // кол-во проводных датчиков освещенности на шине I2C, 0-4
#define LIGHT_SENSORS BH1750_SENSOR // типы датчиков, через запятую (для BH1750 - пишем BH1750_SENSOR, для MAX44009 - пишем MAX44009_SENSOR)
#define LAMP_RELAYS_COUNT 1 // кол-во реле для управления досветкой, максимум - 8 каналов
#define LAMP_RELAYS_PINS 14 // пины или каналы MCP, на которых сидят реле управления досветкой (через запятую, кол-во равно LAMP_RELAYS_COUNT!)
//#define LIGHT_AVERAGING_ENABLED // закомментировать, если не надо использовать усреднение за N показаний
#define LIGHT_AVERAGE_FOR 10 // кол-во показаний, за которые накапливается усреднение.
//#define LIGHT_HARBORING_ENABLED // закомментировать, если не надо использовать загрубление показаний
#define LIGHT_HARBORING_STEP 200 // шаг загрубления, люкс
//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля контроля pH (РАБОТАЕТ ЧЕРЕЗ МИКРОСХЕМУ PCF8574T на шине I2C)
//--------------------------------------------------------------------------------------------------------------------------------
/*
 Принцип работы модуля контроля pH:

   1.Все каналы заведены через микросхему PCF8574T, которую можно подсоединить как прямо к меге,
      так и вытащить через удлинитель I2C;

                2.К одному из каналов подключен датчик понижения уровня жидкости в ёмкости с рабочим раствором, 
      который при срабатывании выдаёт сигнал определённого уровня;

                3.При срабатывании датчика уровня начинается пополнение ёмкости с рабочим раствором, для этого на канал,
                  к которому подключен клапан подачи воды - подаётся определённый уровень;

                4.Как только ёмкость заполнена - начинается контроль pH;

                5.При отклонении pH от нужных значений, в зависимости от направления отклонения -
                  на каналы клапанов для повышения/ понижения значения pH подаётся нужный уровень;

                6.После подачи корректировочного раствора в нужном объёме на канал управление насосом,
                  перемешивающим рабочий раствор, подаётся нужный уровень;

                7.После окончания перемешивания система продолжает контролировать pH, периодически при необходимости
      повторяя вышеописанные действия, чтобы добиться требуемого уровня pH.


 */
#define PCF8574_ADDRESS 0x27 // адрес микросхемы для контроля pH на шине I2C (0x20 - 0x27)
#define PH_SENSOR_PIN 0 // номер аналогового пина, с которого читать показания датчика (0 - нет датчика)
#define PH_SAMPLES_PER_MEASURE 10 // сколько делать замеров на одно измерение pH (1-255)
#define PH_SAMPLES_INTERVAL 20 // сколько миллисекунд между замерами в одном цикле измерения делать (10 - 255)
#define PH_UPDATE_INTERVAL 15678 // через сколько миллисекунд обновлять показания с датчика pH
#define PH_DEFAULT_CALIBRATION 0 // поправочное число по умолчанию, в сотых долях (т.е. 1 - это 0,01 сотая, 10 - это 0,1 и т.п.)
#define PH_DEFAULT_TARGET 700 // желаемое значение pH раствора на выходе, по умолчанию, целое число (700 = 7.00, 651 = 6.51 и т.п.)
#define PH_DEFAULT_HISTERESIS 50 // значение гистерезиса по умолчанию, в сотых долях (50 = 0.5, 100 = 1.0, 123 = 1.23 и т.п.).
#define PH_DEFAULT_MIX_PUMP_TIME 60 // время работы насоса перемешивания по умолчанию, после каждой корректировки pH, секунд
#define PH_DEFAULT_REAGENT_PUMP_TIME 2 // время работы подачи реагента по умолчанию, для изменения pH на 0.1, секунд
#define PH_MV_PER_7_PH 2000 // кол-во милливольт, при  которых датчик показывает 7 pH
//#define PH_REVERSIVE_MEASURE // раскомментировать, если датчик pH имеет реверсивное изменение вольтажа при изменении pH
#define PH_CONTROL_CHECK_INTERVAL 10000 // через сколько миллисекунд контролировать значение pH на предмет попадания в эталонный диапазон
#define PH_FLOW_LEVEL_SENSOR_CHANNEL 0 // номер канала микросхемы PCF8574, на который заведён сигнал с датчика уровня воды
#define PH_FLOW_LEVEL_TRIGGERED  HIGH // уровень, при котором датчик уровня воды считается сработавшим
#define PH_FLOW_ADD_CHANNEL 1 // номер канала микросхемы PCF8574 для включения клапана подачи воды
#define PH_FLOW_ADD_OFF  LOW // уровень, при котором клапан подачи воды выключен
#define PH_FLOW_ADD_ON  HIGH // уровень, при котором клапан подачи воды включен
#define PH_PLUS_CHANNEL 2 // номер канала микросхемы PCF8574 для повышения уровня pH
#define PH_MINUS_CHANNEL 3 // номер канала микросхемы PCF8574 для понижения уровня pH
#define PH_CONTROL_VALVE_ON  HIGH // уровень, включающий клапан поправочного раствора
#define PH_CONTROL_VALVE_OFF  LOW // уровень, выключающий клапан поправочного раствора
#define PH_MIX_PUMP_CHANNEL 4 // номер канала микросхемы PCF8574 для насоса перемешивания раствора
#define PH_MIX_PUMP_ON  HIGH // уровень для включения насоса перемешивания раствора
#define PH_MIX_PUMP_OFF  LOW // уровень для выключения насоса перемешивания раствора
//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля датчиков влажности почвы
//--------------------------------------------------------------------------------------------------------------------------------
#define SUPPORTED_SOIL_MOISTURE_SENSORS 2 // кол-во проводных датчиков влажности почвы
#define SOIL_MOISTURE_SENSORS {58, ANALOG_SOIL_MOISTURE}, {57, ANALOG_SOIL_MOISTURE} // АНАЛОГОВЫЕ пины, на которых сидят датчики влажности почвы (через запятую, кол-во равно SUPPORTED_SOIL_MOISTURE_SENSORS!)
#define SOIL_MOISTURE_UPDATE_INTERVAL 10000 // через сколько мс обновлять показания с датчиков влажности почвы
#define SOIL_MOISTURE_100_PERCENT 450 // какие показания analogRead соответствуют датчику, погруженному в воду
#define SOIL_MOISTURE_0_PERCENT 1023 // какие показания analogRead соответствуют датчику на воздухе, т.е. полностью сухой почве
//#define USE_SOIL_MOISTURE_SENSORS_POWER_MANAGEMENT // раскомментировать, если нужно управлять питанием датчиков влажности почвы.
#define SOIL_MOISTURE_POWER_ON_DELAY 200 // сколько миллисекунд ждать перед подачей питания до чтения с датчиков
#define SOIL_MOISTURE_POWER_DRIVE_MODE  DRIVE_MCP23017 // режимы управления пином питания датчиков влажности почвы - [DRIVE_DIRECT, DRIVE_MCP23S17, DRIVE_MCP23017]
#define SOIL_MOISTURE_MCP23S17_ADDRESS 0 // дрес микросхемы MCP23S17, через которую рулим питанием датчиков (если управление в режиме DRIVE_MCP23S17)
#define SOIL_MOISTURE_MCP23017_ADDRESS 0 // адрес микросхемы MCP23017, через которую рулим питанием датчиков (если управление в режиме DRIVE_MCP23017)
#define SOIL_MOISTURE_POWER_PIN 34 // пин или канал MCP управления питанием датчиков влажности почвы
#define SOIL_MOISTURE_POWER_ON  LOW // уровень для включения питания датчиков
#define SOIL_MOISTURE_POWER_OFF  HIGH // уровень для выключения питания датчиков
//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля влажности
//--------------------------------------------------------------------------------------------------------------------------------
#define SUPPORTED_HUMIDITY_SENSORS 2 // кол-во поддерживаемых проводных датчиков влажности
#define STROBE_OFF_LEVEL  HIGH // уровень для разрыва строба датчика
#define STROBE_ON_LEVEL  LOW // уровень для включения строба датчика
#define HUMIDITY_SENSORS H_SENSOR(0,0,SI7021), H_SENSOR(50,0,DHT11) // Список датчиков влажности
//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля температур/управления фрамугами
//--------------------------------------------------------------------------------------------------------------------------------
#define DEF_OPEN_INTERVAL 3000 // время работы мотора на полное открытие/закрытие фрамуги, мс
#define DEF_OPEN_TEMP 25 // температура открытия по умолчанию, градусов Цельсия
#define DEF_CLOSE_TEMP 24 // температура закрытия по умолчанию, градусов Цельсия
#define SUPPORTED_SENSORS 3 // кол-во поддерживаемых проводных датчиков температуры, подсоединённых к контроллеру
//#define MULTIPLE_DS_SENSORS_ON_ONE_PIN // раскомментировать, если нужна поддержка гирлянды датчиков DS18*20 на одном пине.
#define TEMP_SENSORS_PINS 54, 55,  // пины датчиков добавляются через запятую, количеством SUPPORTED_SENSORS.
#define SUPPORTED_WINDOWS 16 // кол-во поддерживаемых окон, максимум 16
#define WINDOWS_RELAYS_PINS 1,2, 3,4, 5,6, 7,8, 9,10, 11,12, 13,14, 15,16, 17,18, 19,20, 21,22, 23,24, 25,26, 27,28, 29,30, 31,32 // пины реле управления фрамугами (попарно, через запятую, по два реле на мотор!)
#define WINDOWS_SHIFT_LATCH_PIN 42 // пин защёлки (нога ST_CP регистра)
#define WINDOWS_SHIFT_DATA_PIN 43 // пин данных (нога DS регистра)
#define WINDOWS_SHIFT_CLOCK_PIN 44 // пин тактирования (нога SH_CP регистра)
#define WINDOWS_SHIFT_OE_PIN 45 // пин, который управляет ногой OE регистра (должен быть подтянут к питанию резистором на 10К)
//--------------------------------------------------------------------------------------------------------------------------------
// настройки концевиков для окон. Для каждого окна - два концевика, на открытие и закрытие.
//--------------------------------------------------------------------------------------------------------------------------------
//#define USE_WINDOWS_ENDSTOPS // закомментировать, если не нужно использовать концевики для окон
#define WINDOWS_ENDSTOPS_DRIVE_MODE  DRIVE_MCP23S17 // режимы опроса концевиков - [DRIVE_DIRECT, DRIVE_MCP23S17, DRIVE_MCP23017]
#define WINDOWS_ENDSTOPS_OPEN_MCP23S17_ADDRESS 2 // адрес микросхемы MCP23S17, через которую опрашиваем концевики открытия (если управление в режиме DRIVE_MCP23S17)
#define WINDOWS_ENDSTOPS_OPEN_MCP23017_ADDRESS 2 // адрес микросхемы MCP23017, через которую опрашиваем концевики открытия (если управление в режиме DRIVE_MCP23017)
#define WINDOWS_ENDSTOPS_CLOSE_MCP23S17_ADDRESS 2 // адрес микросхемы MCP23S17, через которую опрашиваем концевики закрытия (если управление в режиме DRIVE_MCP23S17)
#define WINDOWS_ENDSTOPS_CLOSE_MCP23017_ADDRESS 2 // адрес микросхемы MCP23017, через которую опрашиваем концевики закрытия (если управление в режиме DRIVE_MCP23017)
#define WINDOWS_ENDSTOPS_OPEN_PINS 0,1,2,3 // пины или каналы МСР для опроса концевиков открытия - дописывать в этот массив, через запятую, кол-во равно SUPPORTED_WINDOWS
#define WINDOWS_ENDSTOPS_CLOSE_PINS 0,1,2,3 // пины или каналы МСР для опроса концевиков закрытия - дописывать в этот массив, через запятую, кол-во равно SUPPORTED_WINDOWS
#define WINDOWS_ENDSTOP_TRIGGERED_LEVEL  LOW // уровень срабатывания концевика
//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля управления поливом
//--------------------------------------------------------------------------------------------------------------------------------
#define WATER_DRIVE_MODE  DRIVE_MCP23017 // режимы управления пинами - [DRIVE_DIRECT, DRIVE_MCP23S17, DRIVE_MCP23017]
#define WATER_MCP23S17_ADDRESS 1 // адрес микросхемы MCP23S17, через которую рулим каналами полива (если управление в режиме DRIVE_MCP23S17)
#define WATER_MCP23017_ADDRESS 1 // адрес микросхемы MCP23017, через которую рулим каналами полива (если управление в режиме DRIVE_MCP23017)
#define WATER_PUMP_DRIVE_MODE  DRIVE_MCP23017 // режим управления насосом -  [DRIVE_DIRECT, DRIVE_MCP23S17, DRIVE_MCP23017]
#define WATER_PUMP_MCP23S17_ADDRESS 1 // адрес микросхемы MCP23S17, через которую рулим пином насоса (если управление в режиме DRIVE_MCP23S17)
#define WATER_PUMP_MCP23017_ADDRESS 1 // адрес микросхемы MCP23017, через которую рулим пином насоса (если управление в режиме DRIVE_MCP23017)
#define PUMP_RELAY_PIN 7 // пин или канал МСР, на котором сидит реле управления насосом
#define WATER_PUMP2_DRIVE_MODE  DRIVE_MCP23017 // режим управления вторым насосом - [DRIVE_DIRECT, DRIVE_MCP23S17, DRIVE_MCP23017]
#define WATER_PUMP2_MCP23S17_ADDRESS 1 // адрес микросхемы MCP23S17, через которую рулим пином насоса 2 (если управление в режиме DRIVE_MCP23S17)
#define WATER_PUMP2_MCP23017_ADDRESS 1 // адрес микросхемы MCP23017, через которую рулим пином насоса 2 (если управление в режиме DRIVE_MCP23017)
#define SECOND_PUMP_RELAY_PIN 15 // пин или канал МСР, на котором висит второй насос
#define SECOND_PUMP_START_CHANNEL 7 // с какого канала полива включать второй насос.
#define WATER_RELAY_ON  LOW // уровень для включения реле канала полива
#define WATER_RELAY_OFF  HIGH // уровень для выключения реле канала полива
#define WATER_PUMP_RELAY_ON  LOW // уровень для включения реле насоса
#define WATER_PUMP_RELAY_OFF  HIGH // уровень для выключения реле насоса
#define WATER_RELAYS_COUNT 14 // сколько каналов управления поливом используется (максимум - 16)
#define WATER_RELAYS_PINS 0, 1, 2, 3, 4, 5, 6, 8, 9, 10, 11, 12, 13,  // пины для управления каналами реле - дописывать в этот массив, через запятую, кол-во равно WATER_RELAYS_COUNT!
#define WATERING_STATUS_SAVE_INTERVAL 2 // интервал сохранений времени полива на каналах, в минутах
#define SWITCH_TO_AUTOMATIC_WATERING_MODE_AFTER_MIDNIGHT // закомментировать, если не надо переходить в автоматический режим работы по наступлению полуночи
//#define USE_WATERING_GUARD // закомментировать, если не надо использовать защиту полива (уровни на определённых пинах, при которых полив включаться не будет)
#define WATERING_GUARD_PINS 80, 81, 82 // определения пинов, с которых будет читаться уровень. Если уровень хотя бы на одном из пинов равен уровню WATERING_GUARD_ALERT - то полив и насосы сразу выключатся.
#define WATERING_GUARD_ALERT  HIGH // уровень на пине, при котором тревога полива считается сработавшей
//--------------------------------------------------------------------------------------------------------------------------------
// настройки пищалки
//--------------------------------------------------------------------------------------------------------------------------------
#define USE_BUZZER // раскомментировать, если надо использовать пищалку для звуков при нажатии кнопок на любом из поддерживаемых экранов
#define BUZZER_DURATION 60 // сколько миллисекунд включать пищалку
#define BUZZER_DRIVE_MODE  DRIVE_MCP23017 // как рулим пищалкой [DRIVE_DIRECT, DRIVE_MCP23S17, DRIVE_MCP23017]
#define BUZZER_MCP23S17_ADDRESS 4 // адрес микросхемы MCP23S17, через которую рулим пищалкой (если управление в режиме DRIVE_MCP23S17)
#define BUZZER_MCP23017_ADDRESS 4 // адрес микросхемы MCP23017, через которую рулим пищалкой (если управление в режиме DRIVE_MCP23017)
#define BUZZER_DRIVE_PIN 8 // пин или номер канала расширителя портов, на котором висит пищалка
#define BUZZER_OFF  LOW // уровень для выключения пищалки
#define BUZZER_ON  HIGH // уровень для включения пищалки
//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля LCD 128х64 на базе контроллера ST7920
//--------------------------------------------------------------------------------------------------------------------------------
//#define SCREEN_USE_SOFT_SPI // раскомментировать, если нужен режим программного SPI
#define SCREEN_SCK_PIN 76 // пин SCK, актуален для режима программного SPI (в режиме железного SPI используются соответствующий пин SCK микроконтроллера)
#define SCREEN_MOSI_PIN 75 // пин MOSI, актуален для режима программного SPI (в режиме железного SPI используются соответствующий пин MOSI микроконтроллера)
#define SCREEN_CS_PIN 53 // пин CS
#define SCREEN_BACKLIGHT_PIN 7 // номер пина, на котором будет управление подсветкой (пин с ШИМ !!!)
#define SCREEN_BACKLIGHT_INTENSITY 120 // яркость подсветки (0-255), управляется ШИМ на соответствующем пине (SCREEN_BACKLIGHT_PIN)
#define SCREEN_BACKLIGHT_OFF_DELAY 15000 // через сколько мс выключать подсветку дисплея после перехода в экран ожидания
#define MENU_RESET_DELAY 8000 // через сколько мс, если ничего не сделано, переключаться в экран ожидания
//#define FLIP_SCREEN // повернуть ли экран на 180 градусов при старте (закомментировать, если этого не надо)
//#define SCREEN_HINT_AT_RIGHT // раcкомментировать, если надо выравнивать подсказку выбранного экрана по правой стороне
#define WATER_CHANNELS_SCREEN_ENABLED // закомментировать, если не нужен экран управления отдельными каналами полива
#define WINDOWS_CHANNELS_SCREEN_ENABLED // закомментировать, если не нужен экран управления отдельными каналами окон
#define SENSORS_SETTINGS_ON_SD_ENABLED // закомментировать, если не нужно читать настройки датчиков экрана ожидания с SD-карты
#define MENU_BUTTON_PIN 64 // пин, на котором висит кнопка перехода внутрь экрана и выбора между параметрами. Пин подтянут к питанию резистором на 10К
#define ENCODER_A_PIN 62 // пин МК, на котором сигнал с левой ноги энкодера, подтянут к земле на 10К
#define ENCODER_B_PIN 63 // пин МК, на котором сигнал с правой ноги энкодера, подтянут к земле на 10К
#define ENCODER_PULSES_PER_CLICK 20 // сколько импульсов приходится на один клик энкодера, подбирать опытным путём, для удобства
#define ROTATION_INTERVAL 7000 // через сколько мс менять на экране ожидания показания с датчиков
#define WAIT_SCREEN_SENSORS W_S(StateSoilMoisture,0,"SOIL","Почва"), W_S(StateSoilMoisture,1,"SOIL","Почва модуль"), W_S(StateTemperature,0,"STATE","T внутри"), W_S(StateHumidity,0,"HUMIDITY","Влажность"), W_S(StateLuminosity,0,"LIGHT","Освещенность") // Список датчиков экрана ожидания
//--------------------------------------------------------------------------------------------------------------------------------
// настройки TFT (используется 7'' экран на контроллере SSD1963 с разрешением 800x480)
//--------------------------------------------------------------------------------------------------------------------------------
#define TFT_MODEL CTE70 // SSD1963 (16bit) 800x480 Alternative Init
#define TFT_RS_PIN 38 // TFT RS pin
#define TFT_WR_PIN 39 // TFT WR pin
#define TFT_CS_PIN 40 // TFT CS pin
#define TFT_RST_PIN 41 // TFT RST pin
#define TFT_TOUCH_CLK_PIN 6
#define TFT_TOUCH_CS_PIN 5
#define TFT_TOUCH_DIN_PIN 4
#define TFT_TOUCH_DOUT_PIN 3
#define TFT_TOUCH_IRQ_PIN 2
#define USE_TFT_BACKLIGHT_MANAGE // раскомментировать, если надо использовать управление подсветкой TFT-экрана через внешний канал
#define TFT_BACKLIGHT_DRIVE_MODE  DRIVE_MCP23017 // как рулим подсветкой [DRIVE_DIRECT, DRIVE_MCP23S17, DRIVE_MCP23017]
#define TFT_BACKLIGHT_MCP23S17_ADDRESS 4 // адрес микросхемы MCP23S17, через которую рулим подсветкой (если управление в режиме DRIVE_MCP23S17)
#define TFT_BACKLIGHT_MCP23017_ADDRESS 4 // адрес микросхемы MCP23017, через которую рулим подсветкой (если управление в режиме DRIVE_MCP23017)
#define TFT_BACKLIGHT_DRIVE_PIN 13 // пин или номер канала расширителя портов, на котором висит управление подсветкой
#define TFT_BACKLIGHT_OFF  LOW // уровень для выключения подсветки
#define TFT_BACKLIGHT_ON  HIGH // уровень для включения подсветки
#define TFT_SENSOR_BOXES_COUNT 6 // определение кол-ва датчиков для TFT (максимум - 6)
#define TFT_SENSORS {"STATE",StateTemperature,1,"Снаружи теплицы"}, {"STATE",StateTemperature,0,"Внутри секции 1"}, {"STATE",StateTemperature,2,"Внутри секции 2"}, {"HUMIDITY",StateHumidity,0,"Влажность Si7021"}, {"HUMIDITY",StateHumidity,1,"Влажность DHT22"}, {"LIGHT",StateLuminosity,0,"Освещённость"} // Датчики для TFT-экрана
#define TFT_SENSOR_DECIMAL_SEPARATOR charComma // разделитель целой и дробной части показаний, по умолчанию - запятая (charComma). Используйте charDot для точки.
#define TFT_INIT_DELAY 0 // сколько миллисекунд (при необходимости) ждать перед отсылкой первых команд на дисплей
#define TFT_EXTRA_RESET // закомментировать, если не нужен дополнительный принудительный пересброс экрана по ноге TFT_RST_PIN
//--------------------------------------------------------------------------------------------------------------------------------
// цвета для TFT
//--------------------------------------------------------------------------------------------------------------------------------
#define TFT_BACK_COLOR 0xFF,0xFF,0xFF // цвет фона
#define TFT_BUTTON_COLORS VGA_WHITE, VGA_GRAY, VGA_WHITE, VGA_RED, VGA_BLUE // цвета кнопок
#define TFT_FONT_COLOR 0x4B, 0x4C, 0x4B // цвет шрифта по умолчанию
#define TFT_CHANNELS_BUTTON_COLORS 0x3A8D, VGA_SILVER, VGA_GRAY, VGA_RED, 0xEF7D // цвета кнопок для каналов
#define INFO_BOX_BACK_COLOR 97,44,8 // цвет фона для информационного бокса
#define INFO_BOX_BORDER_COLOR VGA_BLACK // цвет рамки информационного бокса
#define INFO_BOX_CAPTION_COLOR 0x30, 0x7B, 0xB5 // цвет заголовка информационного бокса
#define SENSOR_BOX_FONT_COLOR VGA_WHITE // цвет показаний датчика
#define SENSOR_BOX_UNIT_COLOR VGA_WHITE // цвет единиц изменений датчика
#define MODE_ON_COLOR VGA_GREEN // цвет "вкл", "авто"
#define MODE_OFF_COLOR VGA_MAROON // цвет "выкл", "ручной"
#define CHANNELS_BUTTONS_TEXT_COLOR VGA_WHITE // цвет текста кнопок каналов
#define CHANNELS_BUTTONS_BG_COLOR 0xEF7D // цвет фона кнопок каналов
#define CHANNEL_BUTTONS_TEXT_COLOR 0x3A8D // цвет текста кнопки одного канала
#define TIME_PART_FONT_COLOR VGA_TEAL // цвет текста кнопки установки компонента времени
#define TIME_PART_SELECTED_FONT_COLOR VGA_WHITE // цвет текста активной кнопки компонента времени
#define TIME_PART_BG_COLOR 0xEF7D // цвет фона кнопки компонента времени
#define TIME_PART_SELECTED_BG_COLOR VGA_GREEN // цвет фона выбранной кнопки компонента времени
#define STATUS_ON_COLOR VGA_LIME // цвет статусов на экране ожидания
//--------------------------------------------------------------------------------------------------------------------------------
// настройки подписей и пр.
//--------------------------------------------------------------------------------------------------------------------------------
#define TFT_WINDOW_STATUS_CAPTION "ФРАМУГИ"
#define TFT_WATER_STATUS_CAPTION "ПОЛИВ"
#define TFT_LIGHT_STATUS_CAPTION "ДОСВЕТКА"
#define TFT_STATUS_CAPTION "Статус:"
#define TFT_MODE_CAPTION "Режим:"
#define TFT_WINDOWS_OPEN_CAPTION "открыты"
#define TFT_WINDOWS_CLOSED_CAPTION "закрыты"
#define TFT_WATER_ON_CAPTION "вкл"
#define TFT_WATER_OFF_CAPTION "выкл"
#define TFT_LIGHT_ON_CAPTION "вкл"
#define TFT_LIGHT_OFF_CAPTION "выкл"
#define TFT_AUTO_MODE_CAPTION "авто"
#define TFT_MANUAL_MODE_CAPTION "ручной"
#define OPEN_ALL_LABEL "ОТКРЫТЬ ВСЕ"
#define CLOSE_ALL_LABEL "ЗАКРЫТЬ ВСЕ"
#define TURN_ON_ALL_WATER_LABEL "ВКЛ ПОЛИВ"
#define TURN_OFF_ALL_WATER_LABEL "ВЫКЛ ПОЛИВ"
#define SKIP_WATERING_LABEL "ПРОПУСТИТЬ СЕГОДНЯ"
#define TURN_ON_ALL_LIGHT_LABEL "СВЕТ ВКЛ"
#define TURN_OFF_ALL_LIGHT_LABEL "СВЕТ ВЫКЛ"
#define TFT_TOPEN_CAPTION "Температура открытия:"
#define TFT_TCLOSE_CAPTION "Температура закрытия:"
#define TFT_INTERVAL_CAPTION "Время открытия, с:"
#define TFT_CURRENTTIME_CAPTION "Дата/время (выделите компонент для изменения):"
#define TFT_SENSOR_TEMPERATURE_CAPTION F("Температура #")
#define TFT_SENSOR_HUMIDITY_CAPTION F("Влажность #"))
#define TFT_SENSOR_LUMINOSITY_CAPTION F("Освещенность #")
#define TFT_SENSOR_SOIL_CAPTION F("Почва #")
#define TFT_LIST_SCROLL_UP_CAPTION "Вверх"
#define TFT_LIST_SCROLL_DOWN_CAPTION "Вниз"
//--------------------------------------------------------------------------------------------------------------------------------
// TFT extras
//--------------------------------------------------------------------------------------------------------------------------------
#define TFT_OFF_DELAY 15000 // время выключения при бездействии, миллисекунд
#define TFT_SENSORS_UPDATE_INTERVAL 5000 // через сколько миллисекунд перечитывать показания с датчиков
#define TFT_SENSORS_SCREEN_ENABLED // закомментировать, если не надо показывать экран TFT со списком всех датчиков
//--------------------------------------------------------------------------------------------------------------------------------
// Настройки W5100
//--------------------------------------------------------------------------------------------------------------------------------
#define W5100_REBOOT_PIN 0 // номер пина, на котором будет управление питанием W5100 - пока реализовано только включение
#define W5100_POWER_OFF HIGH // уровень для выключения питания
#define W5100_POWER_ON LOW // уровень для включения питания
//--------------------------------------------------------------------------------------------------------------------------------
// Настройки для модуля с выносным дисплеем
//--------------------------------------------------------------------------------------------------------------------------------
#define REMOTE_DISPLAY_UPDATE_INTERVAL 15000 // интервал обновления показаний датчиков на экране ожидания выносного дисплея, мс
#define REMOTE_DISPLAY_SENSORS {StateTemperature,0,"STATE"}, {StateHumidity,1,"HUMIDITY"}, {StateLuminosity,0,"LIGHT"} // настройки датчиков для выносного дисплея
//--------------------------------------------------------------------------------------------------------------------------------
// Настройки Nextion
//--------------------------------------------------------------------------------------------------------------------------------
#define USE_NEXTION_HARDWARE_UART // закомментировать, если надо использовать программный UART (дополнительные 2 пина) вместо аппаратного (аппаратный остаётся свободен)
#define NEXTION_SOFTWARE_UART_RX_PIN 68 // пин RX для SoftwareSerial при общении с Nextion через программный UART
#define NEXTION_SOFTWARE_UART_TX_PIN 69 // пин ТX для SoftwareSerial при общении с Nextion через программный UART
#define NEXTION_SERIAL Serial3 // какой Serial используем для Nextion
#define NEXTION_SLEEP_DELAY 60 // через сколько секунд переходить в сон, если ничего не сделано на экране
#define NEXTION_WAIT_TIMER 10000 // интервал таймера переключения на экран ожидания, мс
#define NEXTION_ROTATION_INTERVAL 7000 // через сколько мс менять на экране ожидания показания с датчиков
#define NEXTION_WAIT_SCREEN_SENSORS NW_S(StateTemperature,0,"STATE","T внутри"), NW_S(StateHumidity,0,"HUMIDITY","Влажность Si7021"), NW_S(StateHumidity,1,"HUMIDITY","Влажность DHT22"), NW_S(StateLuminosity,0,"LIGHT","Свет") // настройки датчиков для Nextion
//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля учёта воды
//--------------------------------------------------------------------------------------------------------------------------------
#define FIRST_WATERFLOW_PIN 11 // пин для первого расходомера
#define SECOND_WATERFLOW_PIN 11 // пин для второго расходомера
#define WATERFLOW_SENSORS_COUNT 1 // Кол-во расходомеров, доступные значения: 0, 1, 2. Если 0 - никакие показания сниматься не будут, следовательно, пины FIRST_WATERFLOW_PIN и SECOND_WATERFLOW_PIN останутся свободны
#define WATERFLOW_SAVE_DELTA 10 // через сколько накопленных литров сохранять в EEPROM значение с датчика
#define WATERFLOW_CALIBRATION_FACTOR 45 // сколько пульсаций в секунду выдаёт датчик при протекании литра за минуту
#define WATERFLOW_CHECK_FREQUENCY 2000 // через сколько мс обновлять показания с датчиков расхода
//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля управления по SMS (модем  SIM800)
//--------------------------------------------------------------------------------------------------------------------------------
#define GSM_SERIAL Serial2 // какой UART будем использовать при работе с модемом?
#define GSM_AVAILABLE_CHECK_TIME 30000 // через сколько миллисекунд проверять доступность модема посылкой команды AT+CSQ (заодно получаем мощность сигнала)
#define GSM_WAIT_BOOT_TIME 2000 // сколько мс ждать загрузки модема
#define GSM_CHECK_REGISTRATION_INTERVAL 4567 // через сколько мс проверять регистрацию в сети (повторные вызовы с указанным промежутком до тех пор, пока модем не зарегистрируется)
#define GSM_REBOOT_TIME 2000 // сколько миллисекунд держать питание выключенным при перезагрузке модема, если он завис
#define GSM_WAIT_AFTER_REBOOT_TIME 5000 // сколько мс ждать после перезагрузки модема прежде, чем начать обрабатывать команды
#define GSM_MAX_ANSWER_TIME 60000 // через сколько мс, если не получен ответ на команду от модема, считать его зависшим
#define GSM_REBOOT_PIN 65 // номер пина, на котором будет управление питанием GSM-модема
#define GSM_POWER_OFF  HIGH // уровень для выключения питания
#define GSM_POWER_ON  LOW // уровень для включения питания
#define GSM_PULL_GPRS_BY_PING // закомментировать, если не надо периодически пинговать выбранный хост (нужно, чтобы поддерживать GPRS-соединение при очень редких запросах в сеть)
#define GSM_PING_INTERVAL 45000 // интервал в миллисекундах для пинга
#define GSM_PING_HOST F("ya.ru") // хост, который пингуем
#define USE_SIM800_POWERKEY // раскомментировать, если нужно управление подачей питания на SIM800 (вход POWERKEY)
#define SIM800_POWERKEY_PIN 67 // номер пина, на котором будет импульс для включения модема в работу
#define SIM800_POWERKEY_PULSE_DURATION 300 // сколько миллисекунд держать импульс
#define SIM800_POWERKEY_OFF_LEVEL  HIGH // начальный уровень на выходе POWERKEY
#define SIM800_POWERKEY_ON_LEVEL  LOW // уровень, который держится нужное кол-во времени
#define SIM800_WAIT_POWERKEY_AFTER_POWER_ON 500 // сколько миллисекунд ждать после подачи питания до подачи импульса POWERKEY
#define SEND_WINDOW_STATE_IN_STATUS_SMS // закомментировать, если не надо посылать статус окон в СМС статистики
#define SEND_WATER_STATE_IN_STATUS_SMS // закомментировать, если не надо посылать статус полива в СМС статистики
//#define SEND_WORK_STARTED_SMS // закомментировать, если не надо посылать СМС о том, что контроллер начал работу
#define WORK_STARTED_SMS_TEXT F("Контроллер начал работу.") // текст СМС, который будет посылаться при старте контроллера в работу
#define STATUS_SMS_DEFAULT_MODULE1 1 // модуль для первого датчика
#define STATUS_SMS_DEFAULT_SENSOR1 0 // индекс датчика в первом модуле
#define STATUS_SMS_DEFAULT_LABEL1 F("Твнутр") // подпись по умолчанию для первого датчика
#define STATUS_SMS_DEFAULT_MODULE2 1 // модуль для второго датчика
#define STATUS_SMS_DEFAULT_SENSOR2 1 // индекс датчика во втором модуле
#define STATUS_SMS_DEFAULT_LABEL2 F("Тнаруж") // подпись по умолчанию для второго датчика
//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля WI-FI
//--------------------------------------------------------------------------------------------------------------------------------
#define WIFI_SERIAL Serial1 // какой UART использовать для WI-FI?
#define STATION_ID F("TEPLICA") // ID точки доступа, которую создаёт модуль WI-FI
#define STATION_PASSWORD F("12345678") // пароль к точке доступа, которую создаёт вай-фай (МИНИМУМ 8 СИМВОЛОВ, ИНАЧЕН НЕ БУДЕТ РАБОТАТЬ!)
#define ROUTER_ID F("WiFi-Repeater1") // SSID домашнего роутера, к которому коннектится модуль WI-FI
#define ROUTER_PASSWORD F("panasonic") // пароль к домашнему роутеру, к которому коннектится модуль WI-FI
#define WIFI_AVAILABLE_CHECK_TIME 60000 // через сколько миллисекунд проверять доступность ESP посылкой команды AT
#define WIFI_REBOOT_TIME 2000 // сколько миллисекунд держать питание выключенным при перезагрузке ESP, если он завис
#define WIFI_WAIT_BOOT_TIME 2000 // сколько мс ждать загрузки модема
#define WIFI_WAIT_AFTER_REBOOT_TIME 5000 // сколько мс ждать после перезагрузки ESP прежде, чем начать обрабатывать команды
#define WIFI_MAX_ANSWER_TIME 60000 // через сколько мс, если не получен ответ на команду от модема, считать его зависшим
#define WIFI_IPD_READING_TIMEOUT 1000 // таймаут на чтение входящих данных от ESP, миллисекунд (+IPD)
#define WIFI_REBOOT_PIN 59 // номер пина, на котором будет управление питанием ESP
#define WIFI_POWER_OFF  HIGH // уровень для выключения питания
#define WIFI_POWER_ON  LOW // уровень для включения питания
//--------------------------------------------------------------------------------------------------------------------------------
// настройки тревог
//--------------------------------------------------------------------------------------------------------------------------------
#define ALARM_SMS_TEXT F("Тревога! Сработало правило: ") // текст СМС, который отправится при срабатывании тревожного правила, к СМС будет добавлено имя правила
#define CLEAR_ALARM_STATUS // раскомментировать, если надо очищать сработавшие тревоги через указанный ниже промежуток времени. Если тревоги не очищаются - SMS посылается однократно, до перезагрузки контроллера
#define ALARM_CLEAR_INTERVAL 10 // интервал между очистками сработавших тревог, в минутах
