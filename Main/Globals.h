#ifndef _GLOBALS_H
#define _GLOBALS_H

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// ПОЛЬЗОВАТЕЛЬСКИЕ НАСТРОЙКИ
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------------------------------------------------------------------
// директивы условной компиляции:
/*
    в общем случае для предварительной настройки прошивки достаточно закомментировать ту или иную директиву USE_*.
    конкретные настройки пинов и пр. - находятся после директив условной компиляции, и подхватываются только тогда,
    когда соответствующая директива USE_* определена.
 */
//--------------------------------------------------------------------------------------------------------------------------------
#define USE_DS3231_REALTIME_CLOCK // закомментировать, если не хотим использовать модуль реального времени (DS3231)
#define USE_PIN_MODULE // закомментировать, если не нужен модуль управления пинами
#define USE_TEMP_SENSORS // закомментировать, если не нужно управление окнами по температуре
#define USE_WINDOWS_SHIFT_REGISTER // использовать ли сдвиговый регистр 74HC595 для управления окнами, вместо контроля пинов напрямую (см. настройки фрамуг ниже)
// МОДУЛЬ LOOP ПОМЕЧЕН КАК УСТАРЕВШИЙ И ЕГО ИСПОЛЬЗОВАНИЕ НЕ РЕКОМЕНДУЕТСЯ !!!
//#define USE_LOOP_MODULE // закомментировать, если не нужна поддержка модуля LOOP
#define USE_STAT_MODULE // закомментировать, если не нужна поддержка модуля статистики (FREERAM, UPTIME, DATETIME)
#define USE_SMS_MODULE // закомментировать, если не нужна поддержка управления по SMS
#define USE_WATERING_MODULE // закомментировать, если не нужен модуль управления поливом (в принципе, тот же функционал можно реализовать через правила)
#define USE_LUMINOSITY_MODULE // закомментировать, если не нужен модуль контроля освещенности (BH1750)
#define USE_HUMIDITY_MODULE // закомментировать, если не нужен модуль работы с датчиками влажности DHT и Si7021
#define USE_SOIL_MOISTURE_MODULE // закомментировать, если не нужен модуль датчиков влажности почвы
//#define USE_PH_MODULE // закомментировать, если не нужен модуль снятия показаний с датчиков pH и контроля за дозированием реагентов в систему
#define USE_LOG_MODULE // закомментировать, если не нужен модуль логгирования информации. Внимание: модуль работает только с модулем реального времени (USE_DS3231_REALTIME_CLOCK должна быть определена!)
#define USE_DELTA_MODULE // закомментировать, если не нужно собирать показания дельт с датчиков (разница показаний между двумя датчиками)
#define USE_WATERFLOW_MODULE // закомментировать, если не нужны датчик(и) расхода воды (пин(ы) 2 (и 3) меги), настройки - см. ниже
#define USE_COMPOSITE_COMMANDS_MODULE // закомментировать, если не нужен модуль составных команд (позволяет выполнить скопом несколько разных действий, используется правилами)
#define USE_RESERVATION_MODULE // закомментировать, если не нужем модуль резервирования датчиков (когда при отсутствии показаний с одного датчика показания берутся со связанных с ним).
// модуль резервирования нужен для работы правил, если необходимо обеспечить работу правила даже тогда, когда один из датчиков вышел из строя
#define USE_TIMER_MODULE // закомментировать, если не нужна поддержка модуля таймеров (4 таймера)
#define USE_IOT_MODULE // закомментировать, если не нужна отсылка данных на IoT-хранилища (ThingSpeak). Настройки IoT смотрите ниже
#define USE_ALARM_DISPATCHER // закомментировать, если не нужны тревоги (получение СМС при срабатывании правила)
#define USE_WIFI_REBOOT_PIN // закомментировать, если не надо управлять пином выключения питания при зависании ESP (если ESP долго не отвечает на команды - на определённой ноге меняются уровни, настройки - см. ниже) 
#define USE_GSM_REBOOT_PIN // закомментировать, если не надо управлять пином выключения питания при зависании модема (если GSM-модем долго не отвечает на команды - на определённой ноге меняются уровни, настройки - см. ниже) 
#define USE_NRF_REBOOT_PIN // закомментировать, если не надо управлять пином выключения питания при зависании nRF (если nRF долго не отвечает на команды - на определённой ноге меняются уровни, настройки - см. ниже) 
#define USE_W5100_REBOOT_PIN // закомментировать, если не надо управлять пином выключения питания при зависании W5100 (если W5100 долго не отвечает на команды - на определённой ноге меняются уровни, настройки - см. ниже) 
#define USE_EXTERNAL_WATCHDOG // закомментировать, если не нужен внешний контроль зависания меги (мега на определённой ноге дёргает уровни, если уровни не меняются - внешний ватчдог передёргивает питание)
#define USE_WIFI_MODULE_AS_IOT_GATE // закомментировать, если не хотим использовать ESP как один из шлюзов для отсыла данных в IoT
//#define USE_GSM_MODULE_AS_IOT_GATE // закомментировать, если не хотим использовать GSM-модем как один из шлюзов для отсыла данных в IoT
#define USE_UNIVERSAL_SENSORS // закомментировать, если не нужно использовать универсальные модули с датчиками на борту
#define USE_UNI_NEXTION_MODULE // закомментировать, если не нужен выносной модуль с дисплеем Nextion на шине 1-Wire
#define USE_UNI_EXECUTION_MODULE // закомментировать, если не нужна поддержка универсальных исполнительных модулей
#define USE_UNI_REGISTRATION_LINE // закомментировать, если не нужна проводная линия 1-Wire для регистрации универсальных модулей
#define USE_RS485_GATE // закомментировать, если не нужна поддержка опроса универсальных модулей по протоколу RS-485
#define USE_NRF_GATE // закомментировать, если не нужно работать с универсальными модулями по радиоканалу
#define USE_PUMP_RELAY // закомментировать, если не нужен отдельный канал управления насосом при поливе (настройки - ниже)

//--------------------------------------------------------------------------------------------------------------------------------
// шлюзы (ИСПОЛЬЗОВАТЬ ВМЕСТЕ НЕ ДОПУСКАЕТСЯ, прошивка не скомпилируется!)
//--------------------------------------------------------------------------------------------------------------------------------
#define USE_WIFI_MODULE // закомментировать, если не нужна поддержка управления через Wi-Fi (ESP8266) (не работает совместно с USE_W5100_MODULE!)
//#define USE_W5100_MODULE // закомментировать, если не нужна работа по Ethernet через W5100 (не работает совместно с USE_WIFI_MODULE!)
//--------------------------------------------------------------------------------------------------------------------------------
// экраны (ИСПОЛЬЗОВАТЬ ВМЕСТЕ НЕ ДОПУСКАЕТСЯ, прошивка не скомпилируется!)
//--------------------------------------------------------------------------------------------------------------------------------
#define USE_LCD_MODULE // закомментировать, если не нужен дисплей 128х64 на базе контроллера ST7920
//#define USE_NEXTION_MODULE // закомментировать, если не нужна поддержка Nextion
//--------------------------------------------------------------------------------------------------------------------------------
// информационные диоды
//--------------------------------------------------------------------------------------------------------------------------------
#define USE_READY_DIODE // закомментировать, если не нужен диод, горящий при работе контроллера (пин номер DIODE_READY_PIN)
#define BLINK_READY_DIODE // закомментировать, если не нужно периодически мигать диодом работы
#define USE_WINDOWS_MANUAL_MODE_DIODE // закомментировать, если не нужен диод, мигающий в ручном режиме управления фрамугами (пин DIODE_WINDOWS_MANUAL_MODE_PIN)
#define USE_WATERING_MANUAL_MODE_DIODE // закомментировать, если не нужен диод, мигающий в ручном режиме управления поливом (пин DIODE_WATERING_MANUAL_MODE_PIN)
#define USE_LIGHT_MANUAL_MODE_DIODE // закомментировать, если не нужен диод, мигающий в ручном режиме управления досветкой (пин DIODE_LIGHT_MANUAL_MODE_PIN)


//--------------------------------------------------------------------------------------------------------------------------------
/*
 ниже идут конкретные настройки того или иного функционала.
 */
//--------------------------------------------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------------------------------------------
// НАСТРОЙКИ ВНЕШНЕГО ВАТЧДОГА
//--------------------------------------------------------------------------------------------------------------------------------
#define WATCHDOG_REBOOT_PIN A5        // номер пина, на котором будут меняться уровни
#define WATCHDOG_WORK_INTERVAL 5000   // через сколько миллисекунд на ноге будет высокий уровень
#define WATCHDOG_PULSE_DURATION 20    // сколько миллисекунд держать высокий уровень на ноге

//--------------------------------------------------------------------------------------------------------------------------------
// НАСТРОЙКИ УНИВЕРСАЛЬНЫХ МОДУЛЕЙ С ДАТЧИКАМИ, А ТАКЖЕ ИСПОЛНИТЕЛЬНЫХ УНИВЕРСАЛЬНЫХ МОДУЛЕЙ
//--------------------------------------------------------------------------------------------------------------------------------
#define UNI_REGISTRATION_PIN 28             // номер пина, на котором будут регистрироваться модули в системе
#define UNI_MODULE_UPDATE_INTERVAL 2000     // через сколько мс обновлять показания с универсального модуля
#define UNI_WIRED_MODULES_COUNT 1           // сколько проводных линий для универсальных модулей используется (0 - нисколько)
// ДЛЯ ПЛАТЫ ВЫВОДЫ ПО УМОЛЧАНИЮ, ПОДТЯНУТЫЕ РЕЗИСТОРАМИ - A11, A12, A13
#define UNI_WIRED_MODULES A12              //, A13 // номера пинов (через запятую), на которых висят универсальные модули, кол-вом  UNI_WIRED_MODULES_COUNT
// показания с каких датчиков передавать выносному модулю с дисплеем Nextion? максимум 5 датчиков 
#define UNI_NEXTION_WAIT_SCREEN_SENSORS {StateTemperature,0,"STATE"}, {StateHumidity,1,"HUMIDITY"}, {StateLuminosity,0,"LIGHT"}
//--------------------------------------------------------------------------------------------------------------------------------
// настройки RS-485
//--------------------------------------------------------------------------------------------------------------------------------
#define RS_485_SERIAL Serial3                 // ВНИМАНИЕ! СЛЕДИТЕ ЗА ОТСУТСТВИЕМ КОНФЛИКТОВ С SERIAL. ЭТОТ ЖЕ SERIAL ИСПОЛЬЗУЕТСЯ Nextion, т.е. либо Nextion по Serial, либо - RS-485!!!
#define RS_485_UCSR UCSR3A                    // регистр, связанный с номером UART RS_485_SERIAL
#define RS_485_TXC TXC3                       // бит ТХ, связанный с номером UART RS_485_SERIAL
#define RS_485_DE_PIN 26                      // номер пина, на котором будет происходить переключение приёма/передачи по RS-485
#define RS485_SPEED 57600                     // скорость работы по RS-485
#define RS495_STATE_PUSH_FREQUENCY 1000       // через сколько миллисекунд писать в шину RS-485 слепок состояния контроллера
#define RS485_ONE_SENSOR_UPDATE_INTERVAL 1234 // через сколько миллисекунд запрашивать с шины RS-485 показания одного датчика (полный цикл опроса будет равен интервалу*кол-во датчиков в системе)
#define RS485_BYTES_TIMEOUT 10                // кол-во байт, после неуспешной попытки вычитки которых принимать решение о таймауте (если данные по RS-485 не ходят - увеличьте это значение).
//--------------------------------------------------------------------------------------------------------------------------------
// настройки nRF
//--------------------------------------------------------------------------------------------------------------------------------
#define UNI_DEFAULT_RF_CHANNEL 19 // номер канала для nRF по умолчанию
#define NRF_CE_PIN A8             // номер пина CE для модуля nRF
#define NRF_CSN_PIN A9            // номер пина CSN для модуля nRF
#define NRF_CONTROLLER_STATE_CHECK_FREQUENCY 789 // через сколько миллисекунд проверять смену состояния контроллера (для отсылки в эфир при изменениях)
#define NRF_REBOOT_PIN 30         // номер пина для пересброса питания nRF (в текущей версии управление питанием не реализовано - на этот пин для платы просто подаётся нужный уровень)
#define NRF_POWER_ON HIGH
#define NRF_POWER_OFF LOW

//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля периодических таймеров (4 штуки)
//--------------------------------------------------------------------------------------------------------------------------------
#define TIMER_ON HIGH // уровень, который надо выставлять на пине, когда таймер включён
#define TIMER_OFF LOW // уровень, который надо выставлять на пине, когда таймер выключён

//--------------------------------------------------------------------------------------------------------------------------------
// настройки EEPROM
//--------------------------------------------------------------------------------------------------------------------------------
#define SETT_HEADER1 0xDE                   // байты, сигнализирующие о наличии сохранённых настроек, первый
#define SETT_HEADER2 0xAD                   // и второй
#define CONTROLLER_ID_EEPROM_ADDR 429       // по какому адресу располагается ID контроллера
#define UNI_SENSOR_INDICIES_EEPROM_ADDR 430 // с какого адреса идут выданные индексы для универсальных сенсоров
#define WATERING_STATUS_EEPROM_ADDR 450     // с какого адреса у нас идут статусы каналов полива (для сохранения флага - сколько поливали сегодня), 50 байт хватит на 9 каналов + 1 канал вида "все каналы" 
#define WATERFLOW_EEPROM_ADDR 550           // с какого адреса у нас будут записываться показания датчиков расхода воды (пишутся только накопительные показания, по 4 байта на счётчик, 2 счётчика = 8 байт, 2 байта - факторы калибровки, 2 оставшихся - про запас)
#define DELTA_SETTINGS_EEPROM_ADDR 562      // с какого адреса в EEPROM начинаются настройки дельт, до начала адреса правил вместится 20 дельт
#define EEPROM_RULES_START_ADDR 1075        // со второго килобайта в EEPROM идут правила
#define PH_SETTINGS_EEPROM_ADDR 2850        // с какого адреса идут настройки PH-модуля: заголовок (2 байта), номер пина, с которого читать показания (1 байт), калибровка (в сотых долях, 2 байта), остальное - пока резерв
#define TIMERS_EEPROM_ADDR 2900             // у нас 4 таймера, на каждый - 10 байт + заголовок (2 байта), итого - 42 байта 
#define RESERVATION_ADDR 2950               // адрес, с которого пишутся настройки резервирования (173 байта до составных команд; 10 списков по 12 байт + 3 байта = 123 байта, запас ещё есть)
#define COMPOSITE_COMMANDS_START_ADDR 3123  // с четвёртого килобайта в EEPROM идут составные команды

//--------------------------------------------------------------------------------------------------------------------------------
// настройки Serial
//--------------------------------------------------------------------------------------------------------------------------------
#define SERIAL_BAUD_RATE 57600 // скорость работы с портом, бод (конфигуратор работает с портом именно на скорости 57600)

//--------------------------------------------------------------------------------------------------------------------------------
// настройки информационных диодов и других пинов 
//--------------------------------------------------------------------------------------------------------------------------------
#define DIODE_READY_PIN 6                  // пин, на котором висит диод индикации работы
#define DIODE_WINDOWS_MANUAL_MODE_PIN 7    // пин, на котором будет диод, мигающий, когда мы в ручном режиме управления окнами
#define DIODE_WATERING_MANUAL_MODE_PIN 8   // пин, на котором висит диод индикации ручного режима управления поливом
#define DIODE_LIGHT_MANUAL_MODE_PIN 9      // пин, на котором висит диод индикации ручного режима управления досветкой
#define WORK_MODE_BLINK_INTERVAL 500       // с какой частотой мигать на пинах индикации ручного режима работы, мс
#define READY_DIODE_BLINK_INTERVAL 5000    // с какой частотой мигать диодом работы, мс
#define SDCARD_CS_PIN 53                   // номер пина Chip Select для SD-модуля 
#define VIRTUAL_PIN_START_NUMBER 80        // номер пина, с которого все пины будут считаться виртуальными, т.е. запись в них производиться не будет, однако в карте пинов (16 байт) этот статус будет отражён.

//--------------------------------------------------------------------------------------------------------------------------------
// настройки железных модулей реле 
//--------------------------------------------------------------------------------------------------------------------------------
#define RELAY_ON LOW               // уровень для включения реле
#define RELAY_OFF HIGH             // уровень для выключения реле
#define SHORT_CIRQUIT_STATE HIGH   // статус пинов, на которых висит реле, чтобы закоротить мотор и не дать ему крутиться

//--------------------------------------------------------------------------------------------------------------------------------
// настройки максимумов
//--------------------------------------------------------------------------------------------------------------------------------
#define MAX_ALERT_RULES 30 // максимальное кол-во поддерживаемых правил
#define MAX_DELTAS 20 // максимальное кол-во дельт. Внимание: на 20 дельт нужно примерно 500 байт в EEPROM, поэтому если нужно больше 20 - смените адрес записи правил в EEPROM на бОльший!

//--------------------------------------------------------------------------------------------------------------------------------
// настройки интервалов обновлений модулей
//--------------------------------------------------------------------------------------------------------------------------------
#define ALERT_UPDATE_INTERVAL 500 // интервал обновления состояния модуля ALERT, мс. Нужен, чтобы часто не разрешать зависимости - это ресурсоёмкая операция.
#define LOGGING_INTERVAL 300000 // интервал логгирования, мс (300000 - каждые 5 минут и т.п.)
#define LUMINOSITY_UPDATE_INTERVAL 3000 // через сколько мс обновлять показания с датчиков освещенности 
#define HUMIDITY_UPDATE_INTERVAL 5000 // через сколько мс обновлять показания с датчиков влажности
#define TEMP_UPDATE_INTERVAL 4990 // через сколько мс обновлять показания с датчиков температуры
#define DELTA_UPDATE_INTERVAL 5010 // через сколько миллисекунд обновлять показания дельт?

//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля освещенности (BH1750)
//--------------------------------------------------------------------------------------------------------------------------------
#define LIGHT_SENSORS_COUNT 2 // кол-во проводных датчиков освещенности, 0, 1 или 2, 2 - максимум
#define LAMP_RELAYS_COUNT 4 // кол-во реле для управления досветкой, максимум - 8 каналов
#define LAMP_RELAYS_PINS 34,35,36,37 // пины, на которых сидят реле управления досветкой (через запятую, кол-во равно LAMP_RELAYS_COUNT!)

//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля контроля pH (РАБОТАЕТ ЧЕРЕЗ МИКРОСХЕМУ PCF8574T на шине I2C !!!)
//--------------------------------------------------------------------------------------------------------------------------------
#define PCF8574_ADDRESS 0x27 // адрес микросхемы для контроля pH на шине I2C (0x20 - 0x27)
#define PH_SENSOR_PIN A2 // номер аналогового пина, с которого читать показания датчика (0 - нет датчика, прикреплённого к меге)
#define PH_SAMPLES_PER_MEASURE 10 // сколько делать замеров на одно измерение pH (1-255)
#define PH_SAMPLES_INTERVAL 20 // сколько миллисекунд между замерами в одном цикле измерения делать (10 - 255)
#define PH_UPDATE_INTERVAL 15678 // через сколько миллисекунд обновлять показания с датчика pH, прикреплённого к меге
#define PH_DEFAULT_CALIBRATION 0 // поправочное число по умолчанию, в сотых долях (т.е. 1 - это 0,01 сотая, 10 - это 0,1 и т.п.)
#define PH_DEFAULT_TARGET 700 // значение контроля pH по умолчанию, целое число (700 = 7.00, 651 = 6.51 и т.п.)
#define PH_DEFAULT_HISTERESIS 50 // значение гистерезиса по умолчанию (50 = 0.5, 100 = 1.0, 123 = 1.23 и т.п.)
#define PH_DEFAULT_MIX_PUMP_TIME 60 // время работы насоса перемешивания по умолчанию, с
#define PH_DEFAULT_REAGENT_PUMP_TIME 2 // время работы подачи реагента по умолчанию, для изменения pH на 0.1, с

#define PH_CONTROL_CHECK_INTERVAL 10000 // через сколько миллисекунд контролировать значение pH

#define PH_FLOW_LEVEL_SENSOR_CHANNEL 0 // номер канала микросхемы PCF8574, на котором будет сигнал с датчика уровня воды
#define PH_FLOW_LEVEL_TRIGGERED HIGH // уровень, при котором датчик уровня воды считается сработавшим

#define PH_FLOW_ADD_CHANNEL 1 // номер канала микросхемы PCF8574 для включения клапана подачи воды
#define PH_FLOW_ADD_OFF LOW // уровень, при котором клапан подачи воды выключен
#define PH_FLOW_ADD_ON HIGH // уровень, при котором клапан подачи воды включен

#define PH_PLUS_CHANNEL 2 // номер канала микросхемы PCF8574 для повышения уровня pH
#define PH_MINUS_CHANNEL 3 // номер канала микросхемы PCF8574 для понижения уровня pH
#define PH_CONTROL_VALVE_ON HIGH // уровень, включающий клапан поправочного раствора
#define PH_CONTROL_VALVE_OFF LOW // уровень, выключающий клапан поправочного раствора

#define PH_MIX_PUMP_CHANNEL 4 // номер канала микросхемы PCF8574 для насоса перемешивания раствора
#define PH_MIX_PUMP_ON HIGH // уровень для включения насоса перемешивания раствора
#define PH_MIX_PUMP_OFF LOW // уровень для выключения насоса перемешивания раствора

//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля датчиков влажности почвы
//--------------------------------------------------------------------------------------------------------------------------------
#define FREQUENCY_SOIL_MOISTURE 1 // частотный датчик влажности почвы
#define ANALOG_SOIL_MOISTURE 2 // аналоговый датчик влажности почвы
//--------------------------------------------------------------------------------------------------------------------------------
#define SUPPORTED_SOIL_MOISTURE_SENSORS 1 // кол-во проводных датчиков влажности почвы
// ДЛЯ ПЛАТЫ ВЫВОДЫ ДАТЧИКОВ ВЛАЖНОСТИ ПОЧВЫ - A2, A3 
#define SOIL_MOISTURE_SENSORS {A2, FREQUENCY_SOIL_MOISTURE}//,{A3, ANALOG_SOIL_MOISTURE} // АНАЛОГОВЫЕ пины, на которых сидят датчики влажности почвы (через запятую, кол-во равно SUPPORTED_SOIL_MOISTURE_SENSORS!)
#define SOIL_MOISTURE_UPDATE_INTERVAL 10000 // через сколько мс обновлять показания с датчиков влажности почвы
#define SOIL_MOISTURE_100_PERCENT 450 // какие показания analogRead соответствуют датчику, погруженному в воду
#define SOIL_MOISTURE_0_PERCENT 1023 // какие показания analogRead соответствуют датчику на воздухе, т.е. полностью сухой почве 

//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля логгирования информации
//--------------------------------------------------------------------------------------------------------------------------------
#define LOG_ACTIONS_ENABLED // закомментировать, если не нужна запись действий на карту (например, события "включён полив" и т.п.)

//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля влажности
//--------------------------------------------------------------------------------------------------------------------------------
#define ADD_HUMIDITY_SENSOR(pin,type) { (pin) , (type) } // для удобства добавления сенсора в массив
// типы поддерживаемых сенсоров: DHT11, DHT2x, SI7021
#define SUPPORTED_HUMIDITY_SENSORS 1 // кол-во поддерживаемых проводных датчиков влажности
// описание поддерживаемых датчиков влажности, через запятую, кол-вом SUPPORTED_HUMIDITY_SENSORS.
// формат: ADD_HUMIDITY_SENSOR(пин, тип)
// следующий после первого датчик добавляется через запятую.
// Примеры:
// для одного датчика:
 #define HUMIDITY_SENSORS ADD_HUMIDITY_SENSOR(9,DHT11)
// для двух и более датчиков:
// #define HUMIDITY_SENSORS ADD_HUMIDITY_SENSOR(12,DHT2x), ADD_HUMIDITY_SENSOR(14,DHT11), ADD_HUMIDITY_SENSOR(15,DHT2x)
// ДЛЯ ПЛАТЫ НОМЕРА ВЫВОДОВ ДЛЯ ДВУХ DHT - A6,A7 !!!
// #define HUMIDITY_SENSORS ADD_HUMIDITY_SENSOR(0,SI7021), ADD_HUMIDITY_SENSOR(A7,DHT2x)

//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля управления фрамугами
//--------------------------------------------------------------------------------------------------------------------------------
#define DEF_OPEN_INTERVAL 30000 // по умолчанию 30 секунд работы мотора на полное открытие/закрытие фрамуги
#define DEF_OPEN_TEMP 25 // температура открытия по умолчанию
#define DEF_CLOSE_TEMP 24 // температура закрытия по умолчанию
#define SUPPORTED_SENSORS 1 // кол-во поддерживаемых проводных датчиков температуры "из коробки"
#define ADD_T(pin,type) {(pin),(type)} // для добавления сенсора в массив

// поддерживаемые типы датчиков температуры: DS18B20 и DS18S20
// для добавления датчика температуры используйте конструкцию ADD_T,
// например, ADD_T(22,DS18S20) добавляет датчик типа DS18S20 на 22-й пин
// ДЛЯ ПЛАТЫ ВЫВОДЫ ПО УМОЛЧАНИЮ, ПОДТЯНУТЫЕ РЕЗИСТОРАМИ - A11, A12, A13
#define TEMP_SENSORS_PINS ADD_T(8,DS18B20)//, ADD_T(32,DS18B20) // пины, на которых висят наши датчики температуры (указываются через запятую, общее кол-во равно SUPPORTED_SENSORS)
//#define TEMP_SENSORS_PINS ADD_T(A11,DS18B20)//, ADD_T(32,DS18B20) // пины, на которых висят наши датчики температуры (указываются через запятую, общее кол-во равно SUPPORTED_SENSORS)
#define SUPPORTED_WINDOWS 20 // кол-во поддерживаемых окон (по два реле на мотор, для 8-ми канального модуля реле - 4 окна)
// пины реле управления фрамугами (попарно, через запятую!) На каждом пине висит одно реле, пара реле (например,
// 40 и 41) образуют одну пару управления DC-мотором. Кол-во реле равно SUPPORTED_WINDOWS*2, соответственно, кол-во используемых
// пинов - всегда чётно! Поэтому будьте внимательны при редактировании этой настройки!
// Как подключается мотор: контакты двигателя подключаются к общим (COM) контактам пары реле.
// Плюс питания - к NO (нормально разомкнутым контактам пары реле).
// Минус питания - к NC (нормально замкнутым контактам реле).

// Настройки пинов управления фрамугами

// если USE_WINDOWS_SHIFT_REGISTER не определена - через эти пины будут управляться реле
#define WINDOWS_RELAYS_PINS 40,41,42,43,44,45,46,47 

// Если USE_WINDOWS_SHIFT_REGISTER определена - управление окнами пойдёт через сдвиговый регистр 74HC595 по пинам, указанным ниже
#define WINDOWS_SHIFT_LATCH_PIN 40     // пин защёлки (нога ST_CP регистра)
#define WINDOWS_SHIFT_DATA_PIN 41      // пин данных (нога DS регистра)
#define WINDOWS_SHIFT_CLOCK_PIN  42    // пин тактирования (нога SH_CP регистра)
#define WINDOWS_SHIFT_OE_PIN 43        // пин, который управляет ногой OE регистра (должен быть подтянут к питанию резистором на 10К) 

//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля управления поливом
//--------------------------------------------------------------------------------------------------------------------------------
#define PUMP1_RELAY_PIN 14     // пин, на котором сидит реле управления насосом
#define PUMP2_RELAY_PIN 15     // пин, на котором сидит реле управления насосом
#define WATER_RELAYS_COUNT 14  // сколько каналов управления поливом используется
// объявляем пины для управления каналами реле - дописывать в этот массив, через запятую,
// кол-во равно WATER_RELAYS_COUNT!
// ДЛЯ ПЛАТЫ НОМЕРА ВЫВОДОВ КОНТРОЛЯ КАНАЛОВ ПОЛИВА - 23,24,25,27
#define WATER_RELAYS_PINS 0,1,2,3,4,5,6,7,8,9,10,11,12,13     // Управление MCP23017

//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля LCD 128х64 на базе контроллера ST7920 
//--------------------------------------------------------------------------------------------------------------------------------
// определяем пины, на которых сидит экран
// подключение:
// пин BLA дисплея идёт на пин управления подсветкой
// пин BLK дисплея идёт на GND
// пин PSB дисплея идёт на GND
// пины GND и VCC дисплея - тут всё ясно
// пин E дисплея идёт на SCREEN_SCK_PIN (программный SPI), или - на хардварный SCK пин микроконтроллера (аппаратный SPI)
// пин R/W дисплея идёт на SCREEN_MOSI_PIN (программный SPI), или - на хардварный MOSI микроконтроллера (аппаратный SPI)
// пин RS дисплея - идёт на SCREEN_CS_PIN, это линия chip select, для выбора ведомого

//#define SCREEN_USE_SOFT_SPI // раскомментировать, если нужен режим программного SPI
#define SCREEN_SCK_PIN 52 // пин SCK, актуален для режима программного SPI (в режиме железного SPI используются соответствующий пин SCK микроконтроллера)
#define SCREEN_MOSI_PIN 51 // пин MOSI, актуален для режима программного SPI (в режиме железного SPI используются соответствующий пин MOSI микроконтроллера)
#define SCREEN_CS_PIN 4 // пин CS
#define SCREEN_BACKLIGHT_PIN 5 // номер пина, на котором будет управление подсветкой (пин с ШИМ !!!)
#define SCREEN_BACKLIGHT_INTENSITY 120 // яркость подсветки (0-255), управляется ШИМ на соответствующем пине (SCREEN_BACKLIGHT_PIN)
#define SCREEN_BACKLIGHT_OFF_DELAY 15000 // через сколько мс выключать подсветку дисплея после перехода в экран ожидания
#define MENU_RESET_DELAY 8000 // через сколько мс, если ничего не сделано, переключаться в экран ожидания
//#define FLIP_SCREEN // повернуть ли экран на 180 градусов при старте (закомментировать, если этого не надо)
//#define SCREEN_HINT_AT_RIGHT //раcкомментировать, если надо выравнивать подсказку выбранного экрана по правой стороне

// настройки кнопки для меню
#define MENU_BUTTON_PIN A10 // пин, на котором висит кнопка перехода внутрь экрана и выбора между параметрами
// кнопка подключается так:
// пин подтянут к питанию резистором на 10К - и соединён с кнопкой
// второй контакт кнопки - к земле. Керамика - желательна.

// настройки энкодера
// энкодер подключается так: средний вывод - к питанию.
// левый и правый - к пинам, дополнительно притянуты к земле резисторами на 10К
#define ENCODER_A_PIN A0 // пин МК, на котором сигнал с левой ноги энкодера
#define ENCODER_B_PIN A1 // пин МК, на котором сигнал с правой ноги энкодера
#define ENCODER_PULSES_PER_CLICK 20 // сколько импульсов приходится на один клик энкодера, подбирать опытным путём, для удобства

// настройки экрана ожидания
#define ROTATION_INTERVAL 7000 // через сколько мс менять на экране ожидания показания с датчиков
#define W_S(type,index, module, displayName) {(type),(index),(module),(displayName) }
// на экране ожидания можно выводить N показаний любых поддерживаемых системой датчиков.
// для добавления показаний с датчика используйте конструкцию W_S.
// показания добавляются в WAIT_SCREEN_SENSORS, через запятую, например:
// добавляем на экран ожидания показания температурного датчика с индексом 0
// модуля STATE:  W_S(StateTemperature,0,"STATE","Tнаруж")
// Пример для нескольких датчиков:
// #define WAIT_SCREEN_SENSORS W_S(StateTemperature,0,"STATE","Твнутр") ,W_S(StateTemperature,1,"STATE","Tнаруж") ,W_S(StateLuminosity,0,"LIGHT","свет") ,W_S(StateHumidity,0,"HUMIDITY","влажность")
// типы показаний: StateTemperature - температура, StateLuminosity - освещенность, StateHumidity - влажность, StateSoilMoisture - влажность почвы, StatePH - значение pH

// определяем вид экрана ожидания тут
#define WAIT_SCREEN_SENSORS W_S(StateSoilMoisture,0,"SOIL","Почва"), W_S(StateSoilMoisture,1,"SOIL","Почва модуль"), W_S(StateTemperature,0,"STATE","T внутри") ,W_S(StateHumidity,0,"HUMIDITY","Влажность") ,W_S(StateLuminosity,0,"LIGHT","Освещенность")


//--------------------------------------------------------------------------------------------------------------------------------
// Настройки W5100
//--------------------------------------------------------------------------------------------------------------------------------
#define W5100_REBOOT_PIN 44 // номер пина, на котором будет управление питанием W5100 - пока реализовано только включение
#define W5100_POWER_OFF LOW // уровень для выключения питания
#define W5100_POWER_ON HIGH // уровень для включения питания

//--------------------------------------------------------------------------------------------------------------------------------
// Настройки Nextion
//--------------------------------------------------------------------------------------------------------------------------------
#define NEXTION_SERIAL Serial3 // какой Serial используем для Nextion (ВНИМАНИЕ! Если используется RS-485 - Nextion по умолчанию сидит на этом же Serial, конфликт!)
#define NEXTION_BAUD_RATE 9600 // скорость обмена командами с дисплеем
#define NEXTION_SLEEP_DELAY 60 // через сколько секунд переходить в сон, если ничего не сделано на экране
#define NEXTION_WAIT_TIMER 10000 // интервал таймера переключения на экран ожидания, мс
#define NEXTION_ROTATION_INTERVAL 7000 // через сколько мс менять на экране ожидания показания с датчиков

// настройки экрана ожидания
#define NW_S(type,index, module) {(type),(index),(module)}
// на экране ожидания можно выводить N показаний любых поддерживаемых системой датчиков.
// для добавления показаний с датчика используйте конструкцию NW_S.
// показания добавляются в NEXTION_WAIT_SCREEN_SENSORS, через запятую, например:
// добавляем на экран ожидания показания температурного датчика с индексом 0
// модуля STATE:  NW_S(StateTemperature,0,"STATE")
// Пример для нескольких датчиков:
// #define NEXTION_WAIT_SCREEN_SENSORS NW_S(StateTemperature,0,"STATE") ,NW_S(StateTemperature,1,"STATE") ,NW_S(StateLuminosity,0,"LIGHT") ,NW_S(StateHumidity,0,"HUMIDITY")
// типы показаний: StateTemperature - температура, StateLuminosity - освещенность, StateHumidity - влажность.
// На текущий момент Nextion подддерживает вывод только этих типов датчиков, поскольку выводит подписи к типу датчика картинками,
// следовательно - надо менять файл проекта для Nextion. Если вы читаете эти строки и вам необходима такое усовершенствование - 
// дайте мне знать, и я постараюсь добавить этот функционал.

// определяем вид экрана ожидания тут
#define NEXTION_WAIT_SCREEN_SENSORS NW_S(StateTemperature,0,"STATE") ,NW_S(StateHumidity,1,"HUMIDITY") ,NW_S(StateLuminosity,0,"LIGHT")

//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля учёта воды
//--------------------------------------------------------------------------------------------------------------------------------
// модуль занимает пины 2 и 3 меги, т.к. работает по прерываниям.
// поддерживаемые типы датчиков - китайские water flow meter с датчиком Холла.
// подключение простое: питание, земля, линию данных - на пин 2 для первого датчика, на пин 3 - для второго датчика.
#define WATERFLOW_SENSORS_COUNT 2 // доступные значения: 0, 1, 2. Если 0 - никакие показания сниматься не будут, следовательно, пины 2 и 3 останутся свободны
#define WATERFLOW_SAVE_DELTA 10 // через сколько накопленных литров сохранять в EEPROM значение с датчика

// сколько пульсаций в секунду выдаёт датчик при протекании литра за минуту - 
// калибровочное значение, если не совпадает с реальным расходом - подбирать!
#define WATERFLOW_CALIBRATION_FACTOR 45 

#define WATERFLOW_CHECK_FREQUENCY 2000 // через сколько мс обновлять показания с датчиков расхода


//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля управления по SMS (модем NEOWAY M590 или SIM800L)
//--------------------------------------------------------------------------------------------------------------------------------
#define GSM_SERIAL Serial1 // какой хардварный Serial будем использовать при работе с модемом?
#define GSM_EVENT_FUNC serialEvent1 // функция для обработки событий входящего трафика для модуля
#define GSM_BAUDRATE 57600 // скорость работы с GSM-модемом
#define GSM_AVAILABLE_CHECK_TIME 60000 // через сколько миллисекунд проверять доступность модема посылкой команды AT
#define GSM_WAIT_BOOT_TIME 2000 // сколько мс ждать загрузки модема
#define GSM_CHECK_REGISTRATION_INTERVAL 4567 // через сколько мс проверять регистрацию в сети (повторные вызовы с указанным промежутком до тех пор, пока модем не зарегистрируется)
#define GSM_REBOOT_TIME 2000 // сколько миллисекунд держать питание выключенным при перезагрузке модема, если он завис
#define GSM_WAIT_AFTER_REBOOT_TIME 5000 // сколько мс ждать после перезагрузки модема прежде, чем начать обрабатывать команды
#define GSM_MAX_ANSWER_TIME 60000 // через сколько мс, если не получен ответ на команду от модема, считать его зависшим
#define GSM_REBOOT_PIN 12 // номер пина, на котором будет управление питанием GSM-модема
#define GSM_POWER_OFF LOW // уровень для выключения питания
#define GSM_POWER_ON HIGH // уровень для включения питания

// настройки команд запроса баланса для разных операторов
#define TELE2_BALANCE F("*105#") // команда для проверки баланса Tele2 (баланс отсылается хозяину по приходу на контроллер СМС с текстом "#5" или выполнению команды CTGET=SMS|BAL.
#define BEELINE_BALANCE F("*102#") // Билайн
#define MTS_BALANCE F("*100#") // МТС
#define MEGAFON_BALANCE F("*100#") // Мегафон
#define YOTA_BALANCE F("*100#") // Йота
#define MTS_BEL_BALANCE F("*100#") // МТС Беларусь
#define VELCOM_BEL_BALANCE F("*100#") // Velcom Беларусь
#define PRIVET_BEL_BALANCE F("*120#") // Privet Беларусь
#define LIFE_BEL_BALANCE F("*100#") // Life Беларусь

// настройки GPRS разных операторов
// Билайн
#define BEELINE_APN F("internet.beeline.ru")
#define BEELINE_USER F("beeline")
#define BEELINE_PASS F("beeline")

// МТС
#define MTS_APN F("internet.mts.ru")
#define MTS_USER F("mts")
#define MTS_PASS F("mts")

// Мегафон
#define MEGAFON_APN F("internet")
#define MEGAFON_USER F("gdata")
#define MEGAFON_PASS F("gdata")

// Теле2
#define TELE2_APN F("internet.tele2.ru")
#define TELE2_USER F("")
#define TELE2_PASS F("")

// Йота
#define YOTA_APN F("internet.yota")
#define YOTA_USER F("")
#define YOTA_PASS F("")

// МТС Беларусь
#define MTS_BEL_APN F("mts")
#define MTS_BEL_USER F("mts")
#define MTS_BEL_PASS F("mts")

// Velcom Беларусь
#define VELCOM_BEL_APN F("vmi.velcom.by")
#define VELCOM_BEL_USER F("")
#define VELCOM_BEL_PASS F("")

// Privet Беларусь
#define PRIVET_BEL_APN F("wap.privet.by")
#define PRIVET_BEL_USER F("")
#define PRIVET_BEL_PASS F("")

// Life Беларусь
#define LIFE_BEL_APN F("internet.life.com.by")
#define LIFE_BEL_USER F("")
#define LIFE_BEL_PASS F("")
//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля WI-FI
//--------------------------------------------------------------------------------------------------------------------------------
#define WIFI_SERIAL Serial2 // какой хардварный сериал использовать для WI-FI?
#define WIFI_EVENT_FUNC serialEvent2 // функция для обработки событий входящего трафика от модуля
#define WIFI_BAUDRATE 115200 // скорость работы с UART для WI-FI
#define WIFI_TCP_KEEP_ALIVE // не разрывать соединение после отсыла ответа
#define STATION_ID F("TEPLICA") // ID точки доступа, которую создаёт модуль WI-FI
#define STATION_PASSWORD F("12345678") // пароль к точке доступа, которую создаёт вай-фай (МИНИМУМ 8 СИМВОЛОВ, ИНАЧЕН НЕ БУДЕТ РАБОТАТЬ!)
#define ROUTER_ID F("")  // SSID домашнего роутера, к которому коннектится модуль WI-FI
#define ROUTER_PASSWORD F("") // пароль к домашнему роутеру, к которому коннектится модуль WI-FI

#define WIFI_AVAILABLE_CHECK_TIME 60000 // через сколько миллисекунд проверять доступность ESP посылкой команды AT
#define WIFI_REBOOT_TIME 2000 // сколько миллисекунд держать питание выключенным при перезагрузке ESP, если он завис
#define WIFI_WAIT_BOOT_TIME 2000 // сколько мс ждать загрузки модема
#define WIFI_WAIT_AFTER_REBOOT_TIME 5000 // сколько мс ждать после перезагрузки ESP прежде, чем начать обрабатывать команды
#define WIFI_MAX_ANSWER_TIME 30000 // через сколько мс, если не получен ответ на команду от модема, считать его зависшим
#define WIFI_REBOOT_PIN 11 // номер пина, на котором будет управление питанием GSM-модема
#define WIFI_POWER_OFF LOW // уровень для выключения питания
#define WIFI_POWER_ON HIGH // уровень для включения питания

//--------------------------------------------------------------------------------------------------------------------------------
// настройки IoT
//--------------------------------------------------------------------------------------------------------------------------------
#define IOT_USER_AGENT F("greenhouse") // User-agent для запроса
#define THINGSPEAK_IP F("184.106.153.149") // IP сервиса ThingSpeak
#define THINGSPEAK_HOST F("api.thingspeak.com") // Имя хоста ThingSpeak
//--------------------------------------------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------------------------------------------
// настройки тревог
//--------------------------------------------------------------------------------------------------------------------------------
#define ALARM_SMS_TEXT F("Тревога! Сработало правило: ") // текст СМС, который отправится при срабатывании тевожного правила, к СМС будет добавлено имя правила









///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// ||
// \/
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// СЛУЖЕБНЫЕ НАСТРОЙКИ
///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//--------------------------------------------------------------------------------------------------------------------------------
// запрещаем использование более 14 каналов полива в прошивке
//--------------------------------------------------------------------------------------------------------------------------------
#if WATER_RELAYS_COUNT > 14
#error WATER CHANNELS IS LIMITED to 14 !!!
#endif
//--------------------------------------------------------------------------------------------------------------------------------
// запрещаем использование более 20 окон в прошивке
//--------------------------------------------------------------------------------------------------------------------------------
#if SUPPORTED_WINDOWS > 20
#error WINDOWS COUNT IS LIMITED to 20 !!!
#endif
//--------------------------------------------------------------------------------------------------------------------------------
// запрещаем использование более 8 каналов досветки в прошивке
//--------------------------------------------------------------------------------------------------------------------------------
#if LAMP_RELAYS_COUNT > 8
#error LAMP RELAYS COUNT IS LIMITED to 8 !!!
#endif
//--------------------------------------------------------------------------------------------------------------------------------
// запрещаем использование более одного шлюза в прошивке
//--------------------------------------------------------------------------------------------------------------------------------
#if defined(USE_W5100_MODULE) && defined(USE_WIFI_MODULE)
#error PLEASE DONT USE BOTH ESP8266 AND W5100 MODULES !!!
#endif
//--------------------------------------------------------------------------------------------------------------------------------
// запрещаем использовать более одного дисплея в прошивке
//--------------------------------------------------------------------------------------------------------------------------------
#if defined(USE_LCD_MODULE) && defined(USE_NEXTION_MODULE)
#error PLEASE DONT USE TWO OR MORE DISPLAYS !!!
#endif
//--------------------------------------------------------------------------------------------------------------------------------
// ВСЕ НАСТРОЙКИ НИЖЕ - МЕНЯЕМ НА СВОЙ СТРАХ И РИСК, С ПОЛНЫМ ПОНИМАНИЕМ ТОГО, ЧТО ХОТИМ СДЕЛАТЬ. 
//--------------------------------------------------------------------------------------------------------------------------------

#define _DEBUG // отладочный режим (КОНФИГУРАТОР НЕ ЗАПУСКАТЬ, ТОЛЬКО МОНИТОР ПОРТА!)
//#define WIFI_DEBUG // режим отладки Wi-Fi-модуля (КОНФИГУРАТОР НЕ ЗАПУСКАТЬ, ТОЛЬКО МОНИТОР ПОРТА!)
//#define GSM_DEBUG_MODE // режим отладки SMS-модуля (КОНФИГУРАТОР НЕ ЗАПУСКАТЬ, ТОЛЬКО МОНИТОР ПОРТА!)
//#define LOGGING_DEBUG_MODE // раскомментировать для отладочного режима (КОНФИГУРАТОР НЕ ЗАПУСКАТЬ, ТОЛЬКО МОНИТОР ПОРТА!)
//#define LCD_DEBUG // отладочный режим LCD-модуля
//#define ETHERNET_DEBUG // отладочный режим Ethernet-модуля
#define WATER_DEBUG // отладочный режим модуля полива (КОНФИГУРАТОР НЕ ЗАПУСКАТЬ, ТОЛЬКО МОНИТОР ПОРТА!)
//#define NRF_DEBUG // отладочный режим nRF, (НЕ РАБОТАЕТ СОВМЕСТНО С КОНФИГУРАТОРОМ!!!)
//#define RS485_DEBUG // отладочный режим RS-485, (НЕ РАБОТАЕТ СОВМЕСТНО С КОНФИГУРАТОРОМ!!!)
//#define UNI_DEBUG // отладочный режим универсальных модулей, (НЕ РАБОТАЕТ СОВМЕСТНО С КОНФИГУРАТОРОМ!!!)
//#define PH_DEBUG // раскомментировать для отладочного режима (НЕ РАБОТАЕТ СОВМЕСТНО С КОНФИГУРАТОРОМ !!!)
//#define IOT_UNIT_TEST // режим юнит-тестирования, не раскомментировать без понимания того, что делаем.

//--------------------------------------------------------------------------------------------------------------------------------
// настройки максимумов
//--------------------------------------------------------------------------------------------------------------------------------
#define MAX_ARGS_IN_LIST 20 // максимальное кол-во аргументов у команды, передаваемой контроллеру по UART
#define MAX_RECEIVE_BUFFER_LENGTH 256 // максимальная длина (в байтах) пакета в сети, дла защиты от спама

//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля алертов (событий по срабатыванию каких-либо условий)
//--------------------------------------------------------------------------------------------------------------------------------
#define ALERT F("ALERT") // произошло событие
#define VIEW_COMMAND F("VIEW") // команда просмотра события CTGET=ALERT|VIEW|0
#define CNT_COMMAND F("CNT") // сколько зарегистрировано событий CTGET=ALERT|CNT
// правило алерта CTSET=ALERT|RULE_ADD|RuleName|STATE|TEMP|1|>|23|Время начала работы|Продолжительность работы, мин|Маска дней недели|Список связанных правил|Команды для стороннего модуля
// пример №1: CTSET=ALERT|RULE_ADD|N1|STATE|TEMP|1|>|23|0|30|127|N3,N4|CTSET=STATE|WINDOW|ALL|OPEN
// пример №2: CTSET=ALERT|RULE_ADD|N1|STATE|TEMP|1|>|23|0|0|127|_|CTSET=STATE|WINDOW|ALL|OPEN
#define ADD_RULE F("RULE_ADD") // добавить правило
#define RULE_CNT F("RULES_CNT") // кол-во правил CTGET=ALERT|RULES_CNT
#define RULE_VIEW F("RULE_VIEW") // просмотр правила по индексу CTGET=ALERT|RULE_VIEW|0
#define RULE_STATE F("RULE_STATE") // включить/выключить правило по имени CTSET=ALERT|RULE_STATE|RuleName|ON, CTSET=ALERT|RULE_STATE|RuleName|OFF, CTSET=ALERT|RULE_STATE|ALL|OFF
// получить состояние правила по индексу -  CTGET=ALERT|RULE_STATE|0

#define RULE_DELETE F("RULE_DELETE") // удалить правило по имени CTSET=ALERT|RULE_DELETE|RuleName - ПРИ УДАЛЕНИИ ВСЕ ПРАВИЛА СДВИГАЮТСЯ К ГОЛОВЕ ОТ УДАЛЁННОГО !!! 
// Специальный параметр ALL (CTSET=ALERT|RULE_DELETE|ALL) удаляет все правила.

#define SAVE_RULES F("SAVE") // команда "сохранить правила", CTSET=ALERT|SAVE
#define GREATER_THAN F(">") // больше чем
#define GREATER_OR_EQUAL_THAN F(">=") // больше либо равно
#define LESS_THAN F("<") // меньше чем
#define LESS_OR_EQUAL_THAN F("<=") // меньше или равно
#define T_OPEN_MACRO F("%TO%") // макроподстановка температуры открытия из настроек
#define T_CLOSE_MACRO F("%TC%") // макроподстановка температуры закрытия из настроек


//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля логгирования информации
//--------------------------------------------------------------------------------------------------------------------------------
//#define ADD_LOG_HEADER // закомментировать, если не надо добавлять первые строки с информацией, с каких модулей есть данные).
// Первая строка информации имеет вид:
// MODULE_NAME1=MODULE_IDX1,MODULE_NAME2=MODULE_IDX2,MODULE_NAMEn=MODULE_IDXn
// где MODULE_NAMEn - имя модуля, MODULE_IDXn = индекс модуля в системе.
// Вторая строка информации сообщает о типах датчиков, и имеет вид:
// TYPE1=IDX1,TYPEn=IDXn
// где TYPEn - название типа (например, TEMP для температуры), IDXn - числовое представление типа.
//#define LOG_CNANGE_NAME_TO_IDX // раскомментировать, если нужен лог меньшего размера.
// в этом случае в каждой строке вместо имени модуля подставляется его индекс в системе. 
//#define LOG_CHANGE_TYPE_TO_IDX // раскомментировать, если нужен лог меньшего размера.
// в этом случае в каждой строке вместо названия типа датчика подставляется его индекс в системе.
//#define WRITE_ABSENT_SENSORS_DATA // раскомментировать, если надо писать показания датчика, даже если показаний с него нет
#define LOG_TEMP_TYPE F("RT") // тип для температуры, который запишется в файл
#define LOG_HUMIDITY_TYPE F("RH") // тип для влажности, который запишется в файл
#define LOG_LUMINOSITY_TYPE F("RL") // тип для освещенности, который запишется в файл
#define LOG_WATERFLOW_TYPE F("WF") // тип для датчика расхода воды, который запишется в файл
#define LOG_SOIL_TYPE F("SM") // тип для датчика влажности почвы, который запишется в файл
#define LOG_PH_TYPE F("PH") // тип для датчика pH, который запишется в файл
#define COMMA_DELIMITER F(",") // разделитель полей в CSV
#define LOGS_DIRECTORY F("logs") // название папки с логами на карточке
#define ACTIONS_DIRECTORY F("actions") // название папки с логами действий на карточке
#define END_OF_FILE F("END_OF_FILE") // какую строку посылаем, когда весь файл вычитали
#define FOLLOW F("FOLLOW") // ответ, что файл будет выслан следующими строками
#define FILE_COMMAND F("FILE") // получить данные с файла
#define ACTIONS_COMAND F("ACTION") // получить данные с файла действий


//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля освещенности
//--------------------------------------------------------------------------------------------------------------------------------
#define LIGHT_STATE_COMMAND F("STATE") // CTGET=LIGHT|STATE
#define NO_LUMINOSITY_DATA -1 // нет показаний с датчика освещенности

//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля управления фрамугами
//--------------------------------------------------------------------------------------------------------------------------------
#define STATE_OPENING F("OPENING") // Открывается
#define STATE_CLOSING F("CLOSING") // Закрывается
#define STATE_CLOSED F("CLOSED") // Закрыто
#define WM_AUTOMATIC F("AUTO") // автоматический режим управления фрамугами
#define WM_MANUAL F("MANUAL") // ручной режим управления фрамугами
#define WORK_MODE F("MODE") // получить/установить режим работы CTGET=STATE|MODE, CTSET=STATE|MODE|AUTO, CTSET=STATE|MODE|MANUAL
#define WM_INTERVAL F("INTERVAL") // получить/установить интервал на открытие/закрытие окон CTGET=STATE|INTERVAL, CTSET=STATE|INTERVAL|3000
#define STATE_OPEN F("OPEN") // Открыть CTSET=STATE|WINDOW|0|OPEN, CTSET=STATE|WINDOW|ALL|OPEN, CTSET=STATE|WINDOW|0-2|OPEN|2000
#define ALL F("ALL") // отработать все каналы
#define PROP_WINDOW F("WINDOW") // название канала, чтобы было понятно
#define PROP_WINDOW_CNT F("WINDOW_CNT") // кол-во фрамуг CTGET=STATE|WINDOW|WINDOW_CNT
#define PROP_WINDOW_STATEMASK F("STATEMASK") // CTGET=STATE|WINDOW|STATEMASK - получить состояние всех окон в виде маски. Ответ: OK=STATE|WINDOW|STATEMASK|Кол-во окон|Маска,
// где Маска - байты маски в виде шестнадцатеричной строки (например "F0"), для каждого окна в этих байтах - по два бита, их значение: 00 - закрыто, 01 - открывается, 10 - закрывается, 11 - открыто.
// например, для 4-х окон будет 1 байт (4*2 бита = 8 бит = 1 байт), для 5 окон - два байта, при этом во втором байте значащими будут только младшие 2 бита и т.д.
#define TEMP_SETTINGS F("T_SETT") // получить/установить температуры срабатывания, CTGET=STATE|T_SETT, CTSET=STATE|T_SETT|t open|t close
#define NO_TEMPERATURE_DATA -128 // нет данных с датчика температуры

//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля управления поливом
//--------------------------------------------------------------------------------------------------------------------------------
#define WATER_SETTINGS_COMMAND F("T_SETT") // получить/установить настройки управления поливом: CTGET=WATER|T_SETT, CTSET=WATER|T_SETT|WateringOption|WateringDays|WateringTime|StartTime|TurnOnPump , где
// WateringOption = 0 (выключено автоматическое управление поливом), 1 - автоматическое управление поливом включено (все каналы), 2 - автоуправление отдельно по каналам
// WateringDays - битовая маска дней недели (младший бит - понедельник и т.д.)
// WateringTime - продолжительность полива в минутах, максимальное значение - 65535 (два байта)
// StartTime - час начала полива (1 байт) - от 1 до 23
// TurnOnPump - включать (1) или нет (0) насос при активном поливе на любом из каналов
#define WATER_CHANNEL_SETTINGS F("CH_SETT") // получить/установить настройки отдельного канала управления поливом: CTGET=WATER|CH_SETT|0, CTSET=WATER|CH_SETT|0|WateringDays|WateringTime|StartTime
#define WATER_CHANNELS_COUNT_COMMAND F("CHANNELS") // получить кол-во поддерживаемых каналов полива: CTGET=WATER|CHANNELS

//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля контроля воды
//--------------------------------------------------------------------------------------------------------------------------------
#define FLOW_CALIBRATION_COMMAND F("T_SETT") // получить/установить факторы калибровки: CTGET=FLOW|T_SETT, CTSET=FLOW|T_SETT|factor1|factor2

//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля pH
//--------------------------------------------------------------------------------------------------------------------------------
#define PH_SETTINGS_COMMAND F("T_SETT") // получить/установить настройки: CTGET=PH|T_SETT, CTSET=PH|T_SETT|calibration_factor

//--------------------------------------------------------------------------------------------------------------------------------
// настройки главного контроллера
//--------------------------------------------------------------------------------------------------------------------------------
#define MIN_COMMAND_LENGTH 6 // минимальная длина правильной текстовой команды
#define CMD_PREFIX  F("CT") // запрос к контроллеру
#define CHILD_PREFIX F("CD") // запрос к дочернему модулю
#define CMD_PREFIX_LEN  2  // длина префикса команды

#define CMD_SET F("SET") // установить значение
#define CMD_GET F("GET") // получить значение
#define CMD_TYPE_LEN 3 // длина типа команды

//--------------------------------------------------------------------------------------------------------------------------------
#define READY F("READY") // будет напечатано в Serial после загрузки
//--------------------------------------------------------------------------------------------------------------------------------

//--------------------------------------------------------------------------------------------------------------------------------
// состояния вкл/выкл, для команд
//--------------------------------------------------------------------------------------------------------------------------------
#define STATE_ON F("ON") // Включено
#define STATE_ON_ALT F("1") // Включено
#define STATE_OFF F("OFF") // Выключено
#define STATE_OFF_ALT F("0") // Выключено

//--------------------------------------------------------------------------------------------------------------------------------
// ОТВЕТЫ ЗА ЗАПРОСЫ
//--------------------------------------------------------------------------------------------------------------------------------
#define OK_ANSWER F("OK") // ответ - всё ок
#define ERR_ANSWER F("ER") // ответ - ошибка
#define UNKNOWN_MODULE F("UNKNOWN_MODULE") // запрос к неизвестному модулю
#define PARAMS_MISSED F("PARAMS_MISSED") // пропущены параметры команды
#define UNKNOWN_COMMAND F("UNKNOWN_COMMAND") // неизвестная команда
#define NOT_SUPPORTED F("NOT_SUPPORTED") // не поддерживается

//--------------------------------------------------------------------------------------------------------------------------------
// РАЗДЕЛИТЕЛЬ ПАРАМЕТРОВ
//--------------------------------------------------------------------------------------------------------------------------------
#define PARAM_DELIMITER F("|")
//--------------------------------------------------------------------------------------------------------------------------------
// разделитель команды и ответа
//--------------------------------------------------------------------------------------------------------------------------------
#define COMMAND_DELIMITER F("=")

//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля PIN
//--------------------------------------------------------------------------------------------------------------------------------
#define PIN_TOGGLE F("T") // CTGET=PIN|13, CTSET=PIN|13|1, CTSET=PIN|13|ON, CTSET=PIN|13|OFF, CTSET=PIN|13|0, CTSET=PIN|13|T
#define PIN_DETACH F("DETACH") // не устанавливать состояние пина

//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля статистикм
//--------------------------------------------------------------------------------------------------------------------------------
#define FREERAM_COMMAND F("FREERAM") // показать кол-во свободной памяти CTGET=STAT|FREERAM
#define UPTIME_COMMAND F("UPTIME") // показать время работы (в секундах) CTGET=STAT|UPTIME
#ifdef USE_DS3231_REALTIME_CLOCK
#define CURDATETIME_COMMAND F("DATETIME") // вывести текущую дату и время CTGET=STAT|DATETIME
#endif

//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля управления по SMS
//--------------------------------------------------------------------------------------------------------------------------------
#define STAT_COMMAND F("STAT") // получить текущую статистику по SMS, CTGET=SMS|STAT
#define BALANCE_COMMAND F("BAL") // получить баланс по SMS, CTGET=SMS|BAL
#define T_INDOOR F("Твн: ") // температура внутри
#define T_OUTDOOR F("Тнар: ") // температура снаружи
#define W_STATE F("Окна: ") // состояние окон
#define W_CLOSED F("закр") // закрыты
#define W_OPEN F("откр") // открыты
#define WTR_STATE F("Полив: ") // состояние полива
#define WTR_OFF F("выкл") // полив выкл
#define WTR_ON F("вкл") // полив вкл
#define SMS_OPEN_COMMAND F("#1") // открыть окна
#define SMS_CLOSE_COMMAND F("#0") // закрыть окна
#define SMS_STAT_COMMAND F("#9") // получить статистику
#define SMS_AUTOMODE_COMMAND F("#8") // установить автоматический режим работы
#define SMS_WATER_ON_COMMAND F("#4") // включить полив
#define SMS_WATER_OFF_COMMAND F("#6") // выключить полив
#define SMS_BALANCE_COMMAND F("#5") // получить баланс на счету
#define NO_DATA F("<нет данных>") // нет данных с датчика

//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля WI-FI
//--------------------------------------------------------------------------------------------------------------------------------
#define WIFI_SETTINGS_COMMAND F("T_SETT") // установить настройки модуля: CTSET=WIFI|T_SETT|SHOULD_CONNECT_TO_ROUTER(0 or 1)|ROUTER_ID|ROUTER_PASS|STATION_ID|STATION_PASS
#define IP_COMMAND F("IP") // получить текущие IP-адреса, как самой точки доступа, так и назначенный роутером, CTGET=WIFI|IP
#define BUSY F("BUSY") // если мы не можем ответить на запрос - тогда возвращаем ER=WIFI|BUSY

// в дебаг-режиме переводим отладочный порт на такую же скорость, как и скорость
// порта, через который мы работаем с ESP
#ifdef WIFI_DEBUG
#undef SERIAL_BAUD_RATE
#define SERIAL_BAUD_RATE WIFI_BAUDRATE
#warning Serial BAUD RATE IS CHANGED TO WIFI_SERIAL BAUD RATE DUE TO WIFI_DEBUG MODE!
#endif

//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля составных команд
//--------------------------------------------------------------------------------------------------------------------------------
#define CC_ADD_COMMAND F("ADD") // добавить составную команду, CTSET=CC|ADD|ListIndex|CommandAction|AdditionalParam
#define CC_SAVE_COMMAND F("SAVE") // сохранить все настройки составных команд в EEPROM, CTSET=CC|SAVE
#define CC_DELETE_COMMAND F("DEL") // удалить все составные команды, CTSET=CC|DEL
#define CC_PROCESS_COMMAND F("EXEC") // выполнить составную команду, CTSET=CC|EXEC|ListIndex


//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля дельт
//--------------------------------------------------------------------------------------------------------------------------------
#define DELTA_ADD_COMMAND F("ADD") // добавить дельту, CTSET=DELTA|ADD|SensorType|ModuleName1|SensorIndex1|ModuleName2|SensorIndex2
#define DELTA_SAVE_COMMAND F("SAVE") // сохранить все настройки дельт в EEPROM, CTSET=DELTA|SAVE
#define DELTA_DELETE_COMMAND F("DEL") // удалить все дельты, CTSET=DELTA|DEL
#define DELTA_VIEW_COMMAND F("VIEW") // просмотр дельты по индексу, CTGET=DELTA|VIEW|0
#define DELTA_COUNT_COMMAND F("CNT") // получить кол-во сохранённых дельт, CTGET=DELTA|CNT

//--------------------------------------------------------------------------------------------------------------------------------
// настройки модуля LOOP
//--------------------------------------------------------------------------------------------------------------------------------
#define MIN_LOOP_PARAMS 5 // минимальное количество параметров, которые надо передать
#define MAX_LOOP_PARAMS 15 // максимальное кол-во параметров, которые можно передать
#define LOOP_NAME_IDX 0 // имя циклически выполняемой команды
#define COMMAND_TYPE_IDX 1 // индекс типа команды в параметрах
#define INTERVAL_IDX 2 // индекс параметра "интервал"
#define COUNT_PASSES_IDX 3 // индекс параметра "кол-во проходов"
#define MODULE_ID_IDX 4 // индекс ID модуля в параметрах
/*
 * Структура команды LOOP:
 * 
 * LOOP|NAME|SET_OR_GET|INTERVAL|COUNT_PASSES|LINKED_MODULE_ID|PARAMS_FOR_MODULE
 * где
 *  NAME - имя, к которому привязывается циклическая команда
 *  SET_OR_GET = SET или GET команда для связанного модуля
 *  INTERVAL - интервал в мс между вызовами (0 - выключить модуль из циклического опроса)
 *  COUNT_PASSES - кол-во проходов (0 - бесконечно)
 *  LINKED_MODULE_ID - идентификатор модуля для передачи команд
 *  PARAMS_FOR_MODULE - параметры для связанного модуля (разделенные '|')
 *  
 *  Для примера, команда
 *  CTSET=LOOP|MyLoop|SET|500|10|PIN|13|T
 *  передаст параметры 13 и T модулю с идентификатором "PIN" 10 раз через каждые 500 мс
 *  
 *  Выключить модуль из обработки просто:
 *  CTSET=LOOP|MyLoop|SET|0|0|PIN|13
 *  
 *    Если для модуля поступила новая команда - старая перезаписывается, т.е. цепочка команд не поддерживается!
 */

//--------------------------------------------------------------------------------------------------------------------------------
 // свойства модулей
//--------------------------------------------------------------------------------------------------------------------------------
#define PROP_TEMP_CNT F("TEMP_CNT") // кол-во датчиков температуры CTGET=0|PROP|TEMP|TEMP_CNT, CTSET=0|PROP|TEMP|TEMP_CNT|2
#define PROP_RELAY_CNT F("RELAY_CNT") // кол-во каналов реле CTGET=0|PROP|MODULE_NAME|RELAY_CNT, CTSET=0|PROP|MODULE_NAME|RELAY_CNT|2
#define PROP_CNT F("CNT") // свойство - кол-во любых датчиков
#define PROP_TEMP F("TEMP") // нам передали/запросили температуру CTGET=0|PROP|MODULE_NAME|TEMP|0, CTSET=0|PROP|MODULE_NAME|TEMP|0|36,6
#define PROP_LIGHT F("LIGHT") // свойство "освещенность"
#define PROP_HUMIDITY F("HUMIDITY") // свойство "влажность"
#define PROP_PIN F("PIN") // свойство "пин" (для слежения за статусом пинов)
#define PROP_SOIL F("SOIL") // свойство "влажность почвы"
#define PROP_PH F("PH") // свойство pH
#define PROP_FLOW_INCREMENTAL F("AFLOW") // свойство "накопительный расход воды"
#define PROP_FLOW_INSTANT F("BFLOW") // свойство "мгновенный расход воды"
#define PROP_NONE F("_") // нет свойства

//--------------------------------------------------------------------------------------------------------------------------------
// команды модуля "0"
//--------------------------------------------------------------------------------------------------------------------------------
//#define USE_REMOTE_MODULES // раскомментировать, если нужна регистрация модулей на лету (при использовании сторонних железок, общающихся с контроллером)
#define NEWLINE F("\r\n")
#define SETTIME_COMMAND F("DATETIME") // установка даты/времени CTSET=0|DATETIME|DD.MM.YYYY hh:mm:ss
#define ADD_COMMAND F("ADD") // команда регистрации модуля CTSET=0|ADD|MODULE_NAME
#define PING_COMMAND F("PING") // команда пинга контроллера CTGET=0|PING
#define REGISTERED_MODULES_COMMAND F("LIST") // пролистать зарегистрированные модули CTGET=0|LIST
#define SMS_NUMBER_COMMAND F("PHONE") // сохранить/вернуть номер телефона для управления контроллером по СМС: CTSET=0|PHONE|+7918..., CTGET=0|PHONE
#define PONG F("PONG") // ответ на запрос пинга
#define REG_SUCC F("ADDED") // модуль зарегистрирован, или команда обработана
#define REG_DEL F("DELETED") // удалено
#define REG_ERR F("EXIST") // модуль уже зарегистрирован
#define UNKNOWN_PROPERTY F("UNKNOWN_PROPERTY") // неизвестное свойство
#define STATUS_COMMAND F("STAT") // получить статус внутренних состояний в виде закодированного пакета, CTGET=0|STAT
#define RESET_COMMAND F("RST") // перезагрузить контроллер
#define ID_COMMAND F("ID") // получить/установить ID контроллера
#define WIRED_COMMAND F("WIRED") // получить список кол-ва проводных датчиков, CTGET=0|WIRED (Температура|Влажность|Освещенность|Влажность почвы|PH)
#define UNI_COUNT_COMMAND F("UNI") // получить список кол-ва универсальных датчиков, CTGET=0|UNI (Температура|Влажность|Освещенность|Влажность почвы|PH)
#define UNI_NOT_FOUND F("U_NONE") // ответ на запрос CTGET=0|U_SEARCH, если универсального модуля не найдено
#define UNI_SEARCH F("U_SEARCH") // запрос CTGET=0|U_SEARCH, выдаёт информацию об универсальном модуле в формате OK=SCRATCHPAD_DATA и ERR=U_NONE, если датчика на линии нет
#define UNI_REGISTER F("U_REG") // запрос CTSET=0|U_REG|SCRATCHPAD_DATA, регистрирует подсоединённый к линии регистрации датчик, возвращает OK=ADDED, если датчик есть, и ERR=U_NONE, если датчика на линии нет
#define UNI_DIFFERENT_SCRATCHPAD F("SCRATCH_TYPE_ERROR") // ошибка при регистрации, разные типы скратчпада переданы
#define UNI_RF_CHANNEL_COMMAND F("RF") // команда на получение/установку канала для nRF
#define PINS_COMMAND F("PINS") // получить состояние пинов, CTGET=0|PINS, ответ OK=PINS|Кол-во_байт_в_пакете|HEX-пакет_занятых_пинов|HEX-пакет_режима_пинов
//--------------------------------------------------------------------------------------------------------------------------------
#define SD_BUFFER_LENGTH 128 // размер буфера для блочного чтения с SD
//--------------------------------------------------------------------------------------------------------------------------------
// общий буфер для команд
//--------------------------------------------------------------------------------------------------------------------------------
#define SHARED_BUFFER_LENGTH 200 // сколько байт резервировать для общего буфера обмена
#define WINDOWS_STATUS_BIT 0 // номер бита статуса окон (1 - открыты, 0 - закрыты)
#define WINDOWS_MODE_BIT 1 // номер бита режима работы окон (1 - авто, 0 - ручной)
#define WATER_STATUS_BIT 2 // номер бита статуса полива (1 - включен, 0 - выключен)
#define WATER_MODE_BIT 3 // номер бита режима работы полива (1 - авто, 0 - ручной)
#define LIGHT_STATUS_BIT 4 // номер бита состояния досветки (1 - включена, 0 - выключена)
#define LIGHT_MODE_BIT 5 // номер бита режима работы досветки (1 - авто, 0 - ручной)
#define WINDOWS_POS_CHANGED_BIT 6 // бит, выставленный в 1, если окна закончили смену позиции
#define PH_FLOW_ADD_BIT 7 // бит, выставляемый в 1, если насос заполнения бака pH включен
#define PH_MIX_PUMP_BIT 8 // бит, выставляемый в 1, если насос перемешивания pH работает
#define PH_PLUS_PUMP_BIT 9 // бит, выставляемый в 1, если насос повышения pH работает
#define PH_MINUS_PUMP_BIT 10 // бит, выставляемый в 1, если насос понижения pH работает
#define STATUSES_BYTES 2 // сколько байт под статусы у нас используется

#define SAVE_STATUS(bnum,sta) WORK_STATUS.SetStatus((bnum),(sta))
//--------------------------------------------------------------------------------------------------------------------------------
// проверка целостности
//--------------------------------------------------------------------------------------------------------------------------------

 #ifdef _DEBUG
  #define CHECK_PUBLISH_CONSISTENCY { if(PublishSingleton.Busy && PublishSingleton.Text.length() > 0) {Serial.print(F("[ERROR] Attempt to writing to unclear PublishSingleton: ")); Serial.println(PublishSingleton.Text);} }
 #else
  #define CHECK_PUBLISH_CONSISTENCY (void) 0
 #endif

#define UNUSED(expr) do { (void)(expr); } while (0)

#endif
